"""

Core C++ bindings
-----------------
This module encompasses the complete public C++ API of AMICI, which was
exposed via swig. All functions listed here are directly accessible in the
main amici package, i.e., :py:class:`amici.amici.ExpData` is available as
``amici.ExpData``.
Usage of functions and classes from the base ``amici`` package is
generally recommended as they often include convenience wrappers that avoid
common pitfalls when accessing C++ types from python and implement some
nonstandard type conversions.

"""
import sys
import os
if sys.platform == 'win32' and (dll_dirs := os.environ.get('AMICI_DLL_DIRS')):
    for dll_dir in dll_dirs.split(os.pathsep):
        os.add_dll_directory(dll_dir)
from typing import TYPE_CHECKING, Iterable, List, Tuple, Sequence
import numpy as np
if TYPE_CHECKING:
    import numpy
from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')
if __package__ or '.' in __name__:
    from . import _amici
else:
    import _amici
try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = 'proxy of ' + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ''
    return '<%s.%s; %s >' % (self.__class__.__module__, self.__class__.__name__, strthis)

def _swig_setattr_nondynamic_instance_variable(set):

    def set_instance_attr(self, name, value):
        if name == 'thisown':
            self.this.own(value)
        elif name == 'this':
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError('You cannot add instance attributes to %s' % self)
    return set_instance_attr

def _swig_setattr_nondynamic_class_variable(set):

    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and (not isinstance(getattr(cls, name), property)):
            set(cls, name, value)
        else:
            raise AttributeError('You cannot add class attributes to %s' % cls)
    return set_class_attr

def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_SwigPyIterator

    def value(self) -> 'PyObject *':
        return _amici.SwigPyIterator_value(self)

    def incr(self, n: int=1) -> 'swig::SwigPyIterator *':
        return _amici.SwigPyIterator_incr(self, n)

    def decr(self, n: int=1) -> 'swig::SwigPyIterator *':
        return _amici.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> int:
        return _amici.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> bool:
        return _amici.SwigPyIterator_equal(self, x)

    def copy(self) -> 'swig::SwigPyIterator *':
        return _amici.SwigPyIterator_copy(self)

    def next(self) -> 'PyObject *':
        return _amici.SwigPyIterator_next(self)

    def __next__(self) -> 'PyObject *':
        return _amici.SwigPyIterator___next__(self)

    def previous(self) -> 'PyObject *':
        return _amici.SwigPyIterator_previous(self)

    def advance(self, n: int) -> 'swig::SwigPyIterator *':
        return _amici.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> bool:
        return _amici.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> bool:
        return _amici.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: int) -> 'swig::SwigPyIterator &':
        return _amici.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: int) -> 'swig::SwigPyIterator &':
        return _amici.SwigPyIterator___isub__(self, n)

    def __add__(self, n: int) -> 'swig::SwigPyIterator *':
        return _amici.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> int:
        return _amici.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
_amici.SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.DoubleVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.DoubleVector___bool__(self)

    def __len__(self) -> int:
        return _amici.DoubleVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< double,std::allocator< double > > *':
        return _amici.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> float:
        return _amici.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.DoubleVector___setitem__(self, *args)

    def pop(self) -> float:
        return _amici.DoubleVector_pop(self)

    def append(self, x: float):
        return _amici.DoubleVector_append(self, x)

    def empty(self) -> bool:
        return _amici.DoubleVector_empty(self)

    def size(self) -> int:
        return _amici.DoubleVector_size(self)

    def swap(self, v: 'Sequence[float]'):
        return _amici.DoubleVector_swap(self, v)

    def begin(self) -> 'std::vector< double >::iterator':
        return _amici.DoubleVector_begin(self)

    def end(self) -> 'std::vector< double >::iterator':
        return _amici.DoubleVector_end(self)

    def rbegin(self) -> 'std::vector< double >::reverse_iterator':
        return _amici.DoubleVector_rbegin(self)

    def rend(self) -> 'std::vector< double >::reverse_iterator':
        return _amici.DoubleVector_rend(self)

    def clear(self):
        return _amici.DoubleVector_clear(self)

    def get_allocator(self) -> 'std::vector< double >::allocator_type':
        return _amici.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _amici.DoubleVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< double >::iterator':
        return _amici.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _amici.DoubleVector_swiginit(self, _amici.new_DoubleVector(*args))

    def push_back(self, x: float):
        return _amici.DoubleVector_push_back(self, x)

    def front(self) -> float:
        return _amici.DoubleVector_front(self)

    def back(self) -> float:
        return _amici.DoubleVector_back(self)

    def assign(self, n: int, x: float):
        return _amici.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _amici.DoubleVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.DoubleVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.DoubleVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.float64)) + ' >'
    __swig_destroy__ = _amici.delete_DoubleVector
_amici.DoubleVector_swigregister(DoubleVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.IntVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.IntVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.IntVector___bool__(self)

    def __len__(self) -> int:
        return _amici.IntVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< int,std::allocator< int > > *':
        return _amici.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.IntVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> int:
        return _amici.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.IntVector___setitem__(self, *args)

    def pop(self) -> int:
        return _amici.IntVector_pop(self)

    def append(self, x: int):
        return _amici.IntVector_append(self, x)

    def empty(self) -> bool:
        return _amici.IntVector_empty(self)

    def size(self) -> int:
        return _amici.IntVector_size(self)

    def swap(self, v: Sequence[int]):
        return _amici.IntVector_swap(self, v)

    def begin(self) -> 'std::vector< int >::iterator':
        return _amici.IntVector_begin(self)

    def end(self) -> 'std::vector< int >::iterator':
        return _amici.IntVector_end(self)

    def rbegin(self) -> 'std::vector< int >::reverse_iterator':
        return _amici.IntVector_rbegin(self)

    def rend(self) -> 'std::vector< int >::reverse_iterator':
        return _amici.IntVector_rend(self)

    def clear(self):
        return _amici.IntVector_clear(self)

    def get_allocator(self) -> 'std::vector< int >::allocator_type':
        return _amici.IntVector_get_allocator(self)

    def pop_back(self):
        return _amici.IntVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< int >::iterator':
        return _amici.IntVector_erase(self, *args)

    def __init__(self, *args):
        _amici.IntVector_swiginit(self, _amici.new_IntVector(*args))

    def push_back(self, x: int):
        return _amici.IntVector_push_back(self, x)

    def front(self) -> int:
        return _amici.IntVector_front(self)

    def back(self) -> int:
        return _amici.IntVector_back(self)

    def assign(self, n: int, x: int):
        return _amici.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.IntVector_resize(self, *args)

    def insert(self, *args):
        return _amici.IntVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.IntVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.IntVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.int64)) + ' >'
    __swig_destroy__ = _amici.delete_IntVector
_amici.IntVector_swigregister(IntVector)

class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.BoolVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.BoolVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.BoolVector___bool__(self)

    def __len__(self) -> int:
        return _amici.BoolVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< bool,std::allocator< bool > > *':
        return _amici.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.BoolVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args) -> bool:
        return _amici.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.BoolVector___setitem__(self, *args)

    def pop(self) -> bool:
        return _amici.BoolVector_pop(self)

    def append(self, x: bool):
        return _amici.BoolVector_append(self, x)

    def empty(self) -> bool:
        return _amici.BoolVector_empty(self)

    def size(self) -> int:
        return _amici.BoolVector_size(self)

    def swap(self, v: 'BoolVector'):
        return _amici.BoolVector_swap(self, v)

    def begin(self) -> 'std::vector< bool >::iterator':
        return _amici.BoolVector_begin(self)

    def end(self) -> 'std::vector< bool >::iterator':
        return _amici.BoolVector_end(self)

    def rbegin(self) -> 'std::vector< bool >::reverse_iterator':
        return _amici.BoolVector_rbegin(self)

    def rend(self) -> 'std::vector< bool >::reverse_iterator':
        return _amici.BoolVector_rend(self)

    def clear(self):
        return _amici.BoolVector_clear(self)

    def get_allocator(self) -> 'std::vector< bool >::allocator_type':
        return _amici.BoolVector_get_allocator(self)

    def pop_back(self):
        return _amici.BoolVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< bool >::iterator':
        return _amici.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _amici.BoolVector_swiginit(self, _amici.new_BoolVector(*args))

    def push_back(self, x: bool):
        return _amici.BoolVector_push_back(self, x)

    def front(self) -> bool:
        return _amici.BoolVector_front(self)

    def back(self) -> bool:
        return _amici.BoolVector_back(self)

    def assign(self, n: int, x: bool):
        return _amici.BoolVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.BoolVector_resize(self, *args)

    def insert(self, *args):
        return _amici.BoolVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.BoolVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.BoolVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.bool_)) + ' >'
    __swig_destroy__ = _amici.delete_BoolVector
_amici.BoolVector_swigregister(BoolVector)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.StringVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.StringVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.StringVector___bool__(self)

    def __len__(self) -> int:
        return _amici.StringVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< std::string,std::allocator< std::string > > *':
        return _amici.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.StringVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> str:
        return _amici.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.StringVector___setitem__(self, *args)

    def pop(self) -> str:
        return _amici.StringVector_pop(self)

    def append(self, x: str):
        return _amici.StringVector_append(self, x)

    def empty(self) -> bool:
        return _amici.StringVector_empty(self)

    def size(self) -> int:
        return _amici.StringVector_size(self)

    def swap(self, v: 'StringVector'):
        return _amici.StringVector_swap(self, v)

    def begin(self) -> 'std::vector< std::string >::iterator':
        return _amici.StringVector_begin(self)

    def end(self) -> 'std::vector< std::string >::iterator':
        return _amici.StringVector_end(self)

    def rbegin(self) -> 'std::vector< std::string >::reverse_iterator':
        return _amici.StringVector_rbegin(self)

    def rend(self) -> 'std::vector< std::string >::reverse_iterator':
        return _amici.StringVector_rend(self)

    def clear(self):
        return _amici.StringVector_clear(self)

    def get_allocator(self) -> 'std::vector< std::string >::allocator_type':
        return _amici.StringVector_get_allocator(self)

    def pop_back(self):
        return _amici.StringVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< std::string >::iterator':
        return _amici.StringVector_erase(self, *args)

    def __init__(self, *args):
        _amici.StringVector_swiginit(self, _amici.new_StringVector(*args))

    def push_back(self, x: str):
        return _amici.StringVector_push_back(self, x)

    def front(self) -> str:
        return _amici.StringVector_front(self)

    def back(self) -> str:
        return _amici.StringVector_back(self)

    def assign(self, n: int, x: str):
        return _amici.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.StringVector_resize(self, *args)

    def insert(self, *args):
        return _amici.StringVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.StringVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.StringVector_capacity(self)
    __swig_destroy__ = _amici.delete_StringVector
_amici.StringVector_swigregister(StringVector)

class StringDoubleMap(object):
    """
    Swig-Generated class templating :class:`Dict`
    [:class:`str`, :class:`float`] to facilitate interfacing with C++ bindings.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.StringDoubleMap_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.StringDoubleMap___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.StringDoubleMap___bool__(self)

    def __len__(self) -> 'std::map< std::string,double >::size_type':
        return _amici.StringDoubleMap___len__(self)

    def __iter__(self):
        return self.key_iterator()

    def iterkeys(self):
        return self.key_iterator()

    def itervalues(self):
        return self.value_iterator()

    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,double >::key_type const &') -> 'std::map< std::string,double >::mapped_type const &':
        return _amici.StringDoubleMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,double >::key_type const &'):
        return _amici.StringDoubleMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,double >::key_type const &') -> bool:
        return _amici.StringDoubleMap_has_key(self, key)

    def keys(self) -> 'PyObject *':
        return _amici.StringDoubleMap_keys(self)

    def values(self) -> 'PyObject *':
        return _amici.StringDoubleMap_values(self)

    def items(self) -> 'PyObject *':
        return _amici.StringDoubleMap_items(self)

    def __contains__(self, key: 'std::map< std::string,double >::key_type const &') -> bool:
        return _amici.StringDoubleMap___contains__(self, key)

    def key_iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.StringDoubleMap_key_iterator(self)

    def value_iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.StringDoubleMap_value_iterator(self)

    def __setitem__(self, *args):
        return _amici.StringDoubleMap___setitem__(self, *args)

    def asdict(self) -> 'PyObject *':
        return _amici.StringDoubleMap_asdict(self)

    def __init__(self, *args):
        _amici.StringDoubleMap_swiginit(self, _amici.new_StringDoubleMap(*args))

    def empty(self) -> bool:
        return _amici.StringDoubleMap_empty(self)

    def size(self) -> 'std::map< std::string,double >::size_type':
        return _amici.StringDoubleMap_size(self)

    def swap(self, v: 'StringDoubleMap'):
        return _amici.StringDoubleMap_swap(self, v)

    def begin(self) -> 'std::map< std::string,double >::iterator':
        return _amici.StringDoubleMap_begin(self)

    def end(self) -> 'std::map< std::string,double >::iterator':
        return _amici.StringDoubleMap_end(self)

    def rbegin(self) -> 'std::map< std::string,double >::reverse_iterator':
        return _amici.StringDoubleMap_rbegin(self)

    def rend(self) -> 'std::map< std::string,double >::reverse_iterator':
        return _amici.StringDoubleMap_rend(self)

    def clear(self):
        return _amici.StringDoubleMap_clear(self)

    def get_allocator(self) -> 'std::map< std::string,double >::allocator_type':
        return _amici.StringDoubleMap_get_allocator(self)

    def count(self, x: 'std::map< std::string,double >::key_type const &') -> 'std::map< std::string,double >::size_type':
        return _amici.StringDoubleMap_count(self, x)

    def erase(self, *args):
        return _amici.StringDoubleMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,double >::key_type const &') -> 'std::map< std::string,double >::iterator':
        return _amici.StringDoubleMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,double >::key_type const &') -> 'std::map< std::string,double >::iterator':
        return _amici.StringDoubleMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,double >::key_type const &') -> 'std::map< std::string,double >::iterator':
        return _amici.StringDoubleMap_upper_bound(self, x)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(dict(self)) + ' >'
    __swig_destroy__ = _amici.delete_StringDoubleMap
_amici.StringDoubleMap_swigregister(StringDoubleMap)

def stdVec2ndarray(*args) -> 'PyObject *':
    """
    *Overload 1:*

    Convert 1D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :rtype: PyObject
    :return: 

    |

    *Overload 2:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :rtype: PyObject
    :return: 

    |

    *Overload 3:*

    Convert row-major flattened 3D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :rtype: PyObject
    :return: 

    |

    *Overload 4:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :type dim4: int
    :param dim4:
    :rtype: PyObject
    :return: 

    |

    *Overload 5:*

    Convert 1D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :rtype: PyObject
    :return: 

    |

    *Overload 6:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :rtype: PyObject
    :return: 

    |

    *Overload 7:*

    Convert row-major flattened 3D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :rtype: PyObject
    :return: 

    |

    *Overload 8:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :type dim4: int
    :param dim4:
    :rtype: PyObject
    :return: 
    """
    return _amici.stdVec2ndarray(*args)

class SolverPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.SolverPtr_swiginit(self, _amici.new_SolverPtr(*args))

    def __deref__(self) -> 'std::unique_ptr< amici::Solver >::pointer':
        return _amici.SolverPtr___deref__(self)

    def release(self) -> 'std::unique_ptr< amici::Solver >::pointer':
        return _amici.SolverPtr_release(self)

    def reset(self, *args):
        return _amici.SolverPtr_reset(self, *args)

    def swap(self, __u: 'SolverPtr'):
        return _amici.SolverPtr_swap(self, __u)

    def get(self) -> 'std::unique_ptr< amici::Solver >::pointer':
        return _amici.SolverPtr_get(self)

    def __nonzero__(self):
        return _amici.SolverPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_SolverPtr

    def __repr__(self):
        return _solver_repr(self)

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :rtype: Solver
        :return: The clone
        """
        return _amici.SolverPtr_clone(self)

    def getSensitivityMethod(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method
        :rtype: SensitivityMethod
        :return: method enum
        """
        return _amici.SolverPtr_getSensitivityMethod(self)

    def setSensitivityMethod(self, sensi_meth: 'SensitivityMethod'):
        """
        Set sensitivity method
        :type sensi_meth: SensitivityMethod
        :param sensi_meth:
        """
        return _amici.SolverPtr_setSensitivityMethod(self, sensi_meth)

    def getSensitivityMethodPreequilibration(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method during preequilibration
        :rtype: SensitivityMethod
        :return: method enum
        """
        return _amici.SolverPtr_getSensitivityMethodPreequilibration(self)

    def setSensitivityMethodPreequilibration(self, sensi_meth_preeq: 'SensitivityMethod'):
        """
        Set sensitivity method for preequilibration
        :type sensi_meth_preeq: SensitivityMethod
        :param sensi_meth_preeq:
        """
        return _amici.SolverPtr_setSensitivityMethodPreequilibration(self, sensi_meth_preeq)

    def getNewtonMaxSteps(self) -> int:
        """
        Get maximum number of allowed Newton steps for steady state
        computation
        :rtype: int
        :return: 
        """
        return _amici.SolverPtr_getNewtonMaxSteps(self)

    def setNewtonMaxSteps(self, newton_maxsteps: int):
        """
        Set maximum number of allowed Newton steps for steady state
        computation
        :type newton_maxsteps: int
        :param newton_maxsteps:
        """
        return _amici.SolverPtr_setNewtonMaxSteps(self, newton_maxsteps)

    def getNewtonDampingFactorMode(self) -> 'NewtonDampingFactorMode':
        """
        Get a state of the damping factor used in the Newton solver
        :rtype: NewtonDampingFactorMode
        :return: 
        """
        return _amici.SolverPtr_getNewtonDampingFactorMode(self)

    def setNewtonDampingFactorMode(self, dampingFactorMode: 'NewtonDampingFactorMode'):
        """
        Turn on/off a damping factor in the Newton method
        :type dampingFactorMode: NewtonDampingFactorMode
        :param dampingFactorMode:
        """
        return _amici.SolverPtr_setNewtonDampingFactorMode(self, dampingFactorMode)

    def getNewtonDampingFactorLowerBound(self) -> float:
        """
        Get a lower bound of the damping factor used in the Newton solver
        :rtype: float
        :return: 
        """
        return _amici.SolverPtr_getNewtonDampingFactorLowerBound(self)

    def setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound: float):
        """
        Set a lower bound of the damping factor in the Newton solver
        :type dampingFactorLowerBound: float
        :param dampingFactorLowerBound:
        """
        return _amici.SolverPtr_setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound)

    def getSensitivityOrder(self) -> 'SensitivityOrder':
        """
        Get sensitivity order
        :rtype: SensitivityOrder
        :return: sensitivity order
        """
        return _amici.SolverPtr_getSensitivityOrder(self)

    def setSensitivityOrder(self, sensi: 'SensitivityOrder'):
        """
        Set the sensitivity order
        :type sensi: SensitivityOrder
        :param sensi: sensitivity order
        """
        return _amici.SolverPtr_setSensitivityOrder(self, sensi)

    def getRelativeTolerance(self) -> float:
        """
        Get the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :rtype: float
        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeTolerance(self)

    def setRelativeTolerance(self, rtol: float):
        """
        Sets the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeTolerance(self, rtol)

    def getAbsoluteTolerance(self) -> float:
        """
        Get the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :rtype: float
        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteTolerance(self)

    def setAbsoluteTolerance(self, atol: float):
        """
        Sets the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteTolerance(self, atol)

    def getRelativeToleranceFSA(self) -> float:
        """
        Returns the relative tolerances for the forward sensitivity
        problem
        :rtype: float
        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeToleranceFSA(self)

    def setRelativeToleranceFSA(self, rtol: float):
        """
        Sets the relative tolerances for the forward sensitivity problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceFSA(self, rtol)

    def getAbsoluteToleranceFSA(self) -> float:
        """
        Returns the absolute tolerances for the forward sensitivity
        problem
        :rtype: float
        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteToleranceFSA(self)

    def setAbsoluteToleranceFSA(self, atol: float):
        """
        Sets the absolute tolerances for the forward sensitivity problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceFSA(self, atol)

    def getRelativeToleranceB(self) -> float:
        """
        Returns the relative tolerances for the adjoint sensitivity
        problem
        :rtype: float
        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeToleranceB(self)

    def setRelativeToleranceB(self, rtol: float):
        """
        Sets the relative tolerances for the adjoint sensitivity problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceB(self, rtol)

    def getAbsoluteToleranceB(self) -> float:
        """
        Returns the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :rtype: float
        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteToleranceB(self)

    def setAbsoluteToleranceB(self, atol: float):
        """
        Sets the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceB(self, atol)

    def getRelativeToleranceQuadratures(self) -> float:
        """
        Returns the relative tolerance for the quadrature problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceQuadratures(self)

    def setRelativeToleranceQuadratures(self, rtol: float):
        """
        sets the relative tolerance for the quadrature problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceQuadratures(self, rtol)

    def getAbsoluteToleranceQuadratures(self) -> float:
        """
        returns the absolute tolerance for the quadrature problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceQuadratures(self)

    def setAbsoluteToleranceQuadratures(self, atol: float):
        """
        sets the absolute tolerance for the quadrature problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceQuadratures(self, atol)

    def getSteadyStateToleranceFactor(self) -> float:
        """
        returns the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :rtype: float
        :return: steady state simulation tolerance factor
        """
        return _amici.SolverPtr_getSteadyStateToleranceFactor(self)

    def setSteadyStateToleranceFactor(self, factor: float):
        """
        set the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :type factor: float
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.SolverPtr_setSteadyStateToleranceFactor(self, factor)

    def getRelativeToleranceSteadyState(self) -> float:
        """
        returns the relative tolerance for the steady state problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceSteadyState(self)

    def setRelativeToleranceSteadyState(self, rtol: float):
        """
        sets the relative tolerance for the steady state problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceSteadyState(self, rtol)

    def getAbsoluteToleranceSteadyState(self) -> float:
        """
        returns the absolute tolerance for the steady state problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceSteadyState(self)

    def setAbsoluteToleranceSteadyState(self, atol: float):
        """
        sets the absolute tolerance for the steady state problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceSteadyState(self, atol)

    def getSteadyStateSensiToleranceFactor(self) -> float:
        """
        returns the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :rtype: float
        :return: steady state simulation tolerance factor
        """
        return _amici.SolverPtr_getSteadyStateSensiToleranceFactor(self)

    def setSteadyStateSensiToleranceFactor(self, factor: float):
        """
        set the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :type factor: float
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.SolverPtr_setSteadyStateSensiToleranceFactor(self, factor)

    def getRelativeToleranceSteadyStateSensi(self) -> float:
        """
        returns the relative tolerance for the sensitivities of the
        steady state problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceSteadyStateSensi(self)

    def setRelativeToleranceSteadyStateSensi(self, rtol: float):
        """
        sets the relative tolerance for the sensitivities of the
        steady state problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceSteadyStateSensi(self, rtol)

    def getAbsoluteToleranceSteadyStateSensi(self) -> float:
        """
        returns the absolute tolerance for the sensitivities of the
        steady state problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceSteadyStateSensi(self)

    def setAbsoluteToleranceSteadyStateSensi(self, atol: float):
        """
        sets the absolute tolerance for the sensitivities of the
        steady state problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceSteadyStateSensi(self, atol)

    def getMaxSteps(self) -> int:
        """
        returns the maximum number of solver steps for the forward
        problem
        :rtype: int
        :return: maximum number of solver steps
        """
        return _amici.SolverPtr_getMaxSteps(self)

    def setMaxSteps(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the forward problem
        :type maxsteps: int
        :param maxsteps: maximum number of solver steps (positive number)
        """
        return _amici.SolverPtr_setMaxSteps(self, maxsteps)

    def getMaxTime(self) -> float:
        """
        Returns the maximum time allowed for integration
        :rtype: float
        :return: Time in seconds
        """
        return _amici.SolverPtr_getMaxTime(self)

    def setMaxTime(self, maxtime: float):
        """
        Set the maximum CPU time allowed for integration
        :type maxtime: float
        :param maxtime: Time in seconds. Zero means infinite time.
        """
        return _amici.SolverPtr_setMaxTime(self, maxtime)

    def getMaxStepsBackwardProblem(self) -> int:
        """
        returns the maximum number of solver steps for the backward
        problem
        :rtype: int
        :return: maximum number of solver steps
        """
        return _amici.SolverPtr_getMaxStepsBackwardProblem(self)

    def setMaxStepsBackwardProblem(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the backward problem

        :type maxsteps: int
        :param maxsteps: maximum number of solver steps (non-negative number)

        Notes: default behaviour (100 times the value for the forward problem) can
        be restored by passing maxsteps=0
        """
        return _amici.SolverPtr_setMaxStepsBackwardProblem(self, maxsteps)

    def getLinearMultistepMethod(self) -> 'LinearMultistepMethod':
        """
        returns the linear system multistep method
        :rtype: LinearMultistepMethod
        :return: linear system multistep method
        """
        return _amici.SolverPtr_getLinearMultistepMethod(self)

    def setLinearMultistepMethod(self, lmm: 'LinearMultistepMethod'):
        """
        sets the linear system multistep method
        :type lmm: LinearMultistepMethod
        :param lmm: linear system multistep method
        """
        return _amici.SolverPtr_setLinearMultistepMethod(self, lmm)

    def getNonlinearSolverIteration(self) -> 'NonlinearSolverIteration':
        """
        returns the nonlinear system solution method
        :rtype: NonlinearSolverIteration
        :return: 
        """
        return _amici.SolverPtr_getNonlinearSolverIteration(self)

    def setNonlinearSolverIteration(self, iter: 'NonlinearSolverIteration'):
        """
        sets the nonlinear system solution method
        :type iter: NonlinearSolverIteration
        :param iter: nonlinear system solution method
        """
        return _amici.SolverPtr_setNonlinearSolverIteration(self, iter)

    def getInterpolationType(self) -> 'InterpolationType':
        """
        getInterpolationType
        :rtype: InterpolationType
        :return: 
        """
        return _amici.SolverPtr_getInterpolationType(self)

    def setInterpolationType(self, interpType: 'InterpolationType'):
        """
        sets the interpolation of the forward solution that is used for
        the backwards problem
        :type interpType: InterpolationType
        :param interpType: interpolation type
        """
        return _amici.SolverPtr_setInterpolationType(self, interpType)

    def getStateOrdering(self) -> int:
        """
        Gets KLU / SuperLUMT state ordering mode

        :rtype: int
        :return: State-ordering as integer according to
            SUNLinSolKLU::StateOrdering or SUNLinSolSuperLUMT::StateOrdering (which
            differ).
        """
        return _amici.SolverPtr_getStateOrdering(self)

    def setStateOrdering(self, ordering: int):
        """
        Sets KLU / SuperLUMT state ordering mode

        This only applies when linsol is set to LinearSolver::KLU or
        LinearSolver::SuperLUMT. Mind the difference between
        SUNLinSolKLU::StateOrdering and SUNLinSolSuperLUMT::StateOrdering.
        :type ordering: int
        :param ordering: state ordering
        """
        return _amici.SolverPtr_setStateOrdering(self, ordering)

    def getStabilityLimitFlag(self) -> bool:
        """
        returns stability limit detection mode
        :rtype: boolean
        :return: stldet can be false (deactivated) or true (activated)
        """
        return _amici.SolverPtr_getStabilityLimitFlag(self)

    def setStabilityLimitFlag(self, stldet: bool):
        """
        set stability limit detection mode
        :type stldet: boolean
        :param stldet: can be false (deactivated) or true (activated)
        """
        return _amici.SolverPtr_setStabilityLimitFlag(self, stldet)

    def getLinearSolver(self) -> 'LinearSolver':
        """
        getLinearSolver
        :rtype: LinearSolver
        :return: 
        """
        return _amici.SolverPtr_getLinearSolver(self)

    def setLinearSolver(self, linsol: 'LinearSolver'):
        """
        setLinearSolver
        :type linsol: LinearSolver
        :param linsol:
        """
        return _amici.SolverPtr_setLinearSolver(self, linsol)

    def getInternalSensitivityMethod(self) -> 'InternalSensitivityMethod':
        """
        returns the internal sensitivity method
        :rtype: InternalSensitivityMethod
        :return: internal sensitivity method
        """
        return _amici.SolverPtr_getInternalSensitivityMethod(self)

    def setInternalSensitivityMethod(self, ism: 'InternalSensitivityMethod'):
        """
        sets the internal sensitivity method
        :type ism: InternalSensitivityMethod
        :param ism: internal sensitivity method
        """
        return _amici.SolverPtr_setInternalSensitivityMethod(self, ism)

    def getReturnDataReportingMode(self) -> 'RDataReporting':
        """
        returns the ReturnData reporting mode
        :rtype: RDataReporting
        :return: ReturnData reporting mode
        """
        return _amici.SolverPtr_getReturnDataReportingMode(self)

    def setReturnDataReportingMode(self, rdrm: 'RDataReporting'):
        """
        sets the ReturnData reporting mode
        :type rdrm: RDataReporting
        :param rdrm: ReturnData reporting mode
        """
        return _amici.SolverPtr_setReturnDataReportingMode(self, rdrm)

    def nx(self) -> int:
        """
        number of states with which the solver was initialized
        :rtype: int
        :return: x.getLength()
        """
        return _amici.SolverPtr_nx(self)

    def nplist(self) -> int:
        """
        number of parameters with which the solver was initialized
        :rtype: int
        :return: sx.getLength()
        """
        return _amici.SolverPtr_nplist(self)

    def nquad(self) -> int:
        """
        number of quadratures with which the solver was initialized
        :rtype: int
        :return: xQB.getLength()
        """
        return _amici.SolverPtr_nquad(self)

    def computingFSA(self) -> bool:
        """
        check if FSA is being computed
        :rtype: boolean
        :return: flag
        """
        return _amici.SolverPtr_computingFSA(self)

    def computingASA(self) -> bool:
        """
        check if ASA is being computed
        :rtype: boolean
        :return: flag
        """
        return _amici.SolverPtr_computingASA(self)

    def getNewtonStepSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed. If activated, convergence checks are limited to every 25 steps
        in the simulation solver to limit performance impact.
        :rtype: boolean
        :return: boolean flag indicating newton step (true) or the right hand side
            (false)
        """
        return _amici.SolverPtr_getNewtonStepSteadyStateCheck(self)

    def getSensiSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed.
        :rtype: boolean
        :return: boolean flag indicating state and sensitivity equations (true) or
            only state variables (false).
        """
        return _amici.SolverPtr_getSensiSteadyStateCheck(self)

    def setNewtonStepSteadyStateCheck(self, flag: bool):
        """
        Sets how convergence checks for steadystate computation are
        performed.
        :type flag: boolean
        :param flag: boolean flag to pick newton step (true) or the right hand
            side (false, default)
        """
        return _amici.SolverPtr_setNewtonStepSteadyStateCheck(self, flag)

    def setSensiSteadyStateCheck(self, flag: bool):
        """
        Sets for which variables convergence checks for steadystate
        computation are performed.
        :type flag: boolean
        :param flag: boolean flag to pick state and sensitivity equations (true,
            default) or only state variables (false).
        """
        return _amici.SolverPtr_setSensiSteadyStateCheck(self, flag)
    logger = property(_amici.SolverPtr_logger_get, _amici.SolverPtr_logger_set, doc=' logger')
_amici.SolverPtr_swigregister(SolverPtr)

class ReturnDataPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ReturnDataPtr_swiginit(self, _amici.new_ReturnDataPtr(*args))

    def __deref__(self) -> 'std::unique_ptr< amici::ReturnData >::pointer':
        return _amici.ReturnDataPtr___deref__(self)

    def release(self) -> 'std::unique_ptr< amici::ReturnData >::pointer':
        return _amici.ReturnDataPtr_release(self)

    def reset(self, *args):
        return _amici.ReturnDataPtr_reset(self, *args)

    def swap(self, __u: 'ReturnDataPtr'):
        return _amici.ReturnDataPtr_swap(self, __u)

    def get(self) -> 'std::unique_ptr< amici::ReturnData >::pointer':
        return _amici.ReturnDataPtr_get(self)

    def __nonzero__(self):
        return _amici.ReturnDataPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ReturnDataPtr
    id = property(_amici.ReturnDataPtr_id_get, _amici.ReturnDataPtr_id_set, doc='Arbitrary (not necessarily unique) identifier.')
    ts = property(_amici.ReturnDataPtr_ts_get, _amici.ReturnDataPtr_ts_set, doc='timepoints (shape `nt`)')
    xdot = property(_amici.ReturnDataPtr_xdot_get, _amici.ReturnDataPtr_xdot_set, doc=' time derivative (shape `nx`)')
    J = property(_amici.ReturnDataPtr_J_get, _amici.ReturnDataPtr_J_set, doc='\n    Jacobian of differential equation right hand side (shape `nx` x `nx`,\n    row-major)\n    ')
    w = property(_amici.ReturnDataPtr_w_get, _amici.ReturnDataPtr_w_set, doc='\n    w data from the model (recurring terms in xdot, for imported SBML models\n    from python, this contains the flux vector) (shape `nt` x `nw`, row\n    major)\n    ')
    z = property(_amici.ReturnDataPtr_z_get, _amici.ReturnDataPtr_z_set, doc=' event output (shape `nmaxevent` x `nz`, row-major)')
    sigmaz = property(_amici.ReturnDataPtr_sigmaz_get, _amici.ReturnDataPtr_sigmaz_set, doc='\n    event output sigma standard deviation (shape `nmaxevent` x `nz`,\n    row-major)\n    ')
    sz = property(_amici.ReturnDataPtr_sz_get, _amici.ReturnDataPtr_sz_set, doc='\n    parameter derivative of event output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    ssigmaz = property(_amici.ReturnDataPtr_ssigmaz_get, _amici.ReturnDataPtr_ssigmaz_set, doc='\n    parameter derivative of event output standard deviation\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    rz = property(_amici.ReturnDataPtr_rz_get, _amici.ReturnDataPtr_rz_set, doc=' event trigger output (shape `nmaxevent` x `nz`, row-major)')
    srz = property(_amici.ReturnDataPtr_srz_get, _amici.ReturnDataPtr_srz_set, doc='\n    parameter derivative of event trigger output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    s2rz = property(_amici.ReturnDataPtr_s2rz_get, _amici.ReturnDataPtr_s2rz_set, doc='\n    second-order parameter derivative of event trigger output (shape\n    `nmaxevent` x `nztrue` x `nplist` x `nplist`, row-major)\n    ')
    x = property(_amici.ReturnDataPtr_x_get, _amici.ReturnDataPtr_x_set, doc=' state (shape `nt` x `nx`, row-major)')
    sx = property(_amici.ReturnDataPtr_sx_get, _amici.ReturnDataPtr_sx_set, doc='parameter derivative of state (shape `nt` x `nplist` x `nx`, row-major)')
    y = property(_amici.ReturnDataPtr_y_get, _amici.ReturnDataPtr_y_set, doc=' observable (shape `nt` x `ny`, row-major)')
    sigmay = property(_amici.ReturnDataPtr_sigmay_get, _amici.ReturnDataPtr_sigmay_set, doc=' observable standard deviation (shape `nt` x `ny`, row-major)')
    sy = property(_amici.ReturnDataPtr_sy_get, _amici.ReturnDataPtr_sy_set, doc='\n    parameter derivative of observable (shape `nt` x `nplist` x `ny`,\n    row-major)\n    ')
    ssigmay = property(_amici.ReturnDataPtr_ssigmay_get, _amici.ReturnDataPtr_ssigmay_set, doc='\n    parameter derivative of observable standard deviation\n    (shape `nt` x `nplist` x `ny`, row-major)\n    ')
    res = property(_amici.ReturnDataPtr_res_get, _amici.ReturnDataPtr_res_set, doc=' observable (shape `nt*ny`, row-major)')
    sres = property(_amici.ReturnDataPtr_sres_get, _amici.ReturnDataPtr_sres_set, doc='parameter derivative of residual (shape `nt*ny` x `nplist`, row-major)')
    FIM = property(_amici.ReturnDataPtr_FIM_get, _amici.ReturnDataPtr_FIM_set, doc=' fisher information matrix (shape `nplist` x `nplist`, row-major)')
    numsteps = property(_amici.ReturnDataPtr_numsteps_get, _amici.ReturnDataPtr_numsteps_set, doc=' number of integration steps forward problem (shape `nt`)')
    numstepsB = property(_amici.ReturnDataPtr_numstepsB_get, _amici.ReturnDataPtr_numstepsB_set, doc=' number of integration steps backward problem (shape `nt`)')
    numrhsevals = property(_amici.ReturnDataPtr_numrhsevals_get, _amici.ReturnDataPtr_numrhsevals_set, doc=' number of right hand side evaluations forward problem (shape `nt`)')
    numrhsevalsB = property(_amici.ReturnDataPtr_numrhsevalsB_get, _amici.ReturnDataPtr_numrhsevalsB_set, doc=' number of right hand side evaluations backward problem (shape `nt`)')
    numerrtestfails = property(_amici.ReturnDataPtr_numerrtestfails_get, _amici.ReturnDataPtr_numerrtestfails_set, doc=' number of error test failures forward problem (shape `nt`)')
    numerrtestfailsB = property(_amici.ReturnDataPtr_numerrtestfailsB_get, _amici.ReturnDataPtr_numerrtestfailsB_set, doc=' number of error test failures backward problem (shape `nt`)')
    numnonlinsolvconvfails = property(_amici.ReturnDataPtr_numnonlinsolvconvfails_get, _amici.ReturnDataPtr_numnonlinsolvconvfails_set, doc='number of linear solver convergence failures forward problem (shape `nt`)')
    numnonlinsolvconvfailsB = property(_amici.ReturnDataPtr_numnonlinsolvconvfailsB_get, _amici.ReturnDataPtr_numnonlinsolvconvfailsB_set, doc='\n    number of linear solver convergence failures backward problem (shape\n    `nt`)\n    ')
    order = property(_amici.ReturnDataPtr_order_get, _amici.ReturnDataPtr_order_set, doc=' employed order forward problem (shape `nt`)')
    cpu_time = property(_amici.ReturnDataPtr_cpu_time_get, _amici.ReturnDataPtr_cpu_time_set, doc='\n    computation time of forward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_timeB = property(_amici.ReturnDataPtr_cpu_timeB_get, _amici.ReturnDataPtr_cpu_timeB_set, doc='\n    computation time of backward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_time_total = property(_amici.ReturnDataPtr_cpu_time_total_get, _amici.ReturnDataPtr_cpu_time_total_set, doc='\n    total CPU time from entering runAmiciSimulation until exiting [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_status = property(_amici.ReturnDataPtr_preeq_status_get, _amici.ReturnDataPtr_preeq_status_set, doc=' flags indicating success of steady state solver (preequilibration)')
    preeq_cpu_time = property(_amici.ReturnDataPtr_preeq_cpu_time_get, _amici.ReturnDataPtr_preeq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_cpu_timeB = property(_amici.ReturnDataPtr_preeq_cpu_timeB_get, _amici.ReturnDataPtr_preeq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_status = property(_amici.ReturnDataPtr_posteq_status_get, _amici.ReturnDataPtr_posteq_status_set, doc=' flags indicating success of steady state solver  (postequilibration)')
    posteq_cpu_time = property(_amici.ReturnDataPtr_posteq_cpu_time_get, _amici.ReturnDataPtr_posteq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_cpu_timeB = property(_amici.ReturnDataPtr_posteq_cpu_timeB_get, _amici.ReturnDataPtr_posteq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_numsteps = property(_amici.ReturnDataPtr_preeq_numsteps_get, _amici.ReturnDataPtr_preeq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (length = 3)\n    ')
    preeq_numstepsB = property(_amici.ReturnDataPtr_preeq_numstepsB_get, _amici.ReturnDataPtr_preeq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (preequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    posteq_numsteps = property(_amici.ReturnDataPtr_posteq_numsteps_get, _amici.ReturnDataPtr_posteq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (shape `3`) (postequilibration)\n    ')
    posteq_numstepsB = property(_amici.ReturnDataPtr_posteq_numstepsB_get, _amici.ReturnDataPtr_posteq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (postequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    preeq_t = property(_amici.ReturnDataPtr_preeq_t_get, _amici.ReturnDataPtr_preeq_t_set, doc='time when steadystate was reached via simulation (preequilibration)')
    preeq_wrms = property(_amici.ReturnDataPtr_preeq_wrms_get, _amici.ReturnDataPtr_preeq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (preequilibration)\n    ')
    posteq_t = property(_amici.ReturnDataPtr_posteq_t_get, _amici.ReturnDataPtr_posteq_t_set, doc='time when steadystate was reached via simulation (postequilibration)')
    posteq_wrms = property(_amici.ReturnDataPtr_posteq_wrms_get, _amici.ReturnDataPtr_posteq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (postequilibration)\n    ')
    x0 = property(_amici.ReturnDataPtr_x0_get, _amici.ReturnDataPtr_x0_set, doc=' initial state (shape `nx`)')
    x_ss = property(_amici.ReturnDataPtr_x_ss_get, _amici.ReturnDataPtr_x_ss_set, doc=' preequilibration steady state (shape `nx`)')
    sx0 = property(_amici.ReturnDataPtr_sx0_get, _amici.ReturnDataPtr_sx0_set, doc=' initial sensitivities (shape `nplist` x `nx`, row-major)')
    sx_ss = property(_amici.ReturnDataPtr_sx_ss_get, _amici.ReturnDataPtr_sx_ss_set, doc='\n    preequilibration sensitivities\n    (shape `nplist` x `nx`, row-major)\n    ')
    llh = property(_amici.ReturnDataPtr_llh_get, _amici.ReturnDataPtr_llh_set, doc=' log-likelihood value')
    chi2 = property(_amici.ReturnDataPtr_chi2_get, _amici.ReturnDataPtr_chi2_set, doc=' :math:`\\chi^2` value')
    sllh = property(_amici.ReturnDataPtr_sllh_get, _amici.ReturnDataPtr_sllh_set, doc=' parameter derivative of log-likelihood (shape `nplist`)')
    s2llh = property(_amici.ReturnDataPtr_s2llh_get, _amici.ReturnDataPtr_s2llh_set, doc='\n    second-order parameter derivative of log-likelihood\n    (shape `nJ-1` x `nplist`, row-major)\n    ')
    status = property(_amici.ReturnDataPtr_status_get, _amici.ReturnDataPtr_status_set, doc='\n    Simulation status code.\n\n    One of:\n\n    * AMICI_SUCCESS, indicating successful simulation\n    * AMICI_MAX_TIME_EXCEEDED, indicating that the simulation did not finish\n      within the allowed time (see Solver.{set,get}MaxTime)\n    * AMICI_ERROR, indicating that some error occurred during simulation\n      (a more detailed error message will have been printed).\n    * AMICI_NOT_RUN, if no simulation was started\n    ')
    nx = property(_amici.ReturnDataPtr_nx_get, _amici.ReturnDataPtr_nx_set, doc=' number of states (alias `nx_rdata`, kept for backward compatibility)')
    nxtrue = property(_amici.ReturnDataPtr_nxtrue_get, _amici.ReturnDataPtr_nxtrue_set, doc='\n    number of states in the unaugmented system\n    (alias nxtrue_rdata, kept for backward compatibility)\n    ')
    nplist = property(_amici.ReturnDataPtr_nplist_get, _amici.ReturnDataPtr_nplist_set, doc=' number of parameter for which sensitivities were requested')
    nmaxevent = property(_amici.ReturnDataPtr_nmaxevent_get, _amici.ReturnDataPtr_nmaxevent_set, doc=' maximal number of occurring events (for every event type)')
    nt = property(_amici.ReturnDataPtr_nt_get, _amici.ReturnDataPtr_nt_set, doc=' number of considered timepoints')
    newton_maxsteps = property(_amici.ReturnDataPtr_newton_maxsteps_get, _amici.ReturnDataPtr_newton_maxsteps_set, doc=' maximal number of newton iterations for steady state calculation')
    pscale = property(_amici.ReturnDataPtr_pscale_get, _amici.ReturnDataPtr_pscale_set, doc=' scaling of parameterization')
    o2mode = property(_amici.ReturnDataPtr_o2mode_get, _amici.ReturnDataPtr_o2mode_set, doc=' flag indicating whether second-order sensitivities were requested')
    sensi = property(_amici.ReturnDataPtr_sensi_get, _amici.ReturnDataPtr_sensi_set, doc=' sensitivity order')
    sensi_meth = property(_amici.ReturnDataPtr_sensi_meth_get, _amici.ReturnDataPtr_sensi_meth_set, doc=' sensitivity method')
    rdata_reporting = property(_amici.ReturnDataPtr_rdata_reporting_get, _amici.ReturnDataPtr_rdata_reporting_set, doc=' reporting mode')
    sigma_res = property(_amici.ReturnDataPtr_sigma_res_get, _amici.ReturnDataPtr_sigma_res_set, doc='\n     boolean indicating whether residuals for standard deviations have been\n    added\n    ')
    messages = property(_amici.ReturnDataPtr_messages_get, _amici.ReturnDataPtr_messages_set, doc=' log messages')
    nx_rdata = property(_amici.ReturnDataPtr_nx_rdata_get, _amici.ReturnDataPtr_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ReturnDataPtr_nxtrue_rdata_get, _amici.ReturnDataPtr_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ReturnDataPtr_nx_solver_get, _amici.ReturnDataPtr_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ReturnDataPtr_nxtrue_solver_get, _amici.ReturnDataPtr_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ReturnDataPtr_nx_solver_reinit_get, _amici.ReturnDataPtr_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    np = property(_amici.ReturnDataPtr_np_get, _amici.ReturnDataPtr_np_set, doc=' Number of parameters')
    nk = property(_amici.ReturnDataPtr_nk_get, _amici.ReturnDataPtr_nk_set, doc=' Number of constants')
    ny = property(_amici.ReturnDataPtr_ny_get, _amici.ReturnDataPtr_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ReturnDataPtr_nytrue_get, _amici.ReturnDataPtr_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ReturnDataPtr_nz_get, _amici.ReturnDataPtr_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ReturnDataPtr_nztrue_get, _amici.ReturnDataPtr_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ReturnDataPtr_ne_get, _amici.ReturnDataPtr_ne_set, doc=' Number of events')
    nspl = property(_amici.ReturnDataPtr_nspl_get, _amici.ReturnDataPtr_nspl_set, doc=' numer of spline functions in the model')
    nw = property(_amici.ReturnDataPtr_nw_get, _amici.ReturnDataPtr_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ReturnDataPtr_ndwdx_get, _amici.ReturnDataPtr_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ReturnDataPtr_ndwdp_get, _amici.ReturnDataPtr_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ReturnDataPtr_ndwdw_get, _amici.ReturnDataPtr_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ReturnDataPtr_ndxdotdw_get, _amici.ReturnDataPtr_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ReturnDataPtr_ndJydy_get, _amici.ReturnDataPtr_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ReturnDataPtr_ndxrdatadxsolver_get, _amici.ReturnDataPtr_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ReturnDataPtr_ndxrdatadtcl_get, _amici.ReturnDataPtr_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ReturnDataPtr_ndtotal_cldx_rdata_get, _amici.ReturnDataPtr_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ReturnDataPtr_nnz_get, _amici.ReturnDataPtr_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ReturnDataPtr_nJ_get, _amici.ReturnDataPtr_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ReturnDataPtr_ubw_get, _amici.ReturnDataPtr_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ReturnDataPtr_lbw_get, _amici.ReturnDataPtr_lbw_set, doc=' Lower bandwidth of the Jacobian')
_amici.ReturnDataPtr_swigregister(ReturnDataPtr)

class ModelPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ModelPtr_swiginit(self, _amici.new_ModelPtr(*args))

    def __deref__(self) -> 'std::unique_ptr< amici::Model >::pointer':
        return _amici.ModelPtr___deref__(self)

    def release(self) -> 'std::unique_ptr< amici::Model >::pointer':
        return _amici.ModelPtr_release(self)

    def reset(self, *args):
        return _amici.ModelPtr_reset(self, *args)

    def swap(self, __u: 'ModelPtr'):
        return _amici.ModelPtr_swap(self, __u)

    def get(self) -> 'std::unique_ptr< amici::Model >::pointer':
        return _amici.ModelPtr_get(self)

    def __nonzero__(self):
        return _amici.ModelPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ModelPtr

    def clone(self) -> 'Model':
        """
        Clone this instance.
        :rtype: Model
        :return: The clone
        """
        return _amici.ModelPtr_clone(self)

    def initializeSplines(self):
        """Initialization of spline functions"""
        return _amici.ModelPtr_initializeSplines(self)

    def initializeSplineSensitivities(self):
        """Initialization of spline sensitivity functions"""
        return _amici.ModelPtr_initializeSplineSensitivities(self)

    def nplist(self) -> int:
        """
        Get number of parameters wrt to which sensitivities are computed.
        :rtype: int
        :return: Length of sensitivity index vector
        """
        return _amici.ModelPtr_nplist(self)

    def np(self) -> int:
        """
        Get total number of model parameters.
        :rtype: int
        :return: Length of parameter vector
        """
        return _amici.ModelPtr_np(self)

    def nk(self) -> int:
        """
        Get number of constants
        :rtype: int
        :return: Length of constant vector
        """
        return _amici.ModelPtr_nk(self)

    def ncl(self) -> int:
        """
        Get number of conservation laws.
        :rtype: int
        :return: Number of conservation laws (i.e., difference between `nx_rdata`
            and `nx_solver`).
        """
        return _amici.ModelPtr_ncl(self)

    def nx_reinit(self) -> int:
        """
        Get number of solver states subject to reinitialization.
        :rtype: int
        :return: Model member `nx_solver_reinit`
        """
        return _amici.ModelPtr_nx_reinit(self)

    def k(self) -> 'double const *':
        """
        Get fixed parameters.
        :rtype: float
        :return: Pointer to constants array
        """
        return _amici.ModelPtr_k(self)

    def nMaxEvent(self) -> int:
        """
        Get maximum number of events that may occur for each type.
        :rtype: int
        :return: Maximum number of events that may occur for each type
        """
        return _amici.ModelPtr_nMaxEvent(self)

    def setNMaxEvent(self, nmaxevent: int):
        """
        Set maximum number of events that may occur for each type.
        :type nmaxevent: int
        :param nmaxevent: Maximum number of events that may occur for each type
        """
        return _amici.ModelPtr_setNMaxEvent(self, nmaxevent)

    def nt(self) -> int:
        """
        Get number of timepoints.
        :rtype: int
        :return: Number of timepoints
        """
        return _amici.ModelPtr_nt(self)

    def getParameterScale(self) -> 'ParameterScalingVector':
        """
        Get parameter scale for each parameter.
        :rtype: ParameterScalingVector
        :return: Vector of parameter scales
        """
        return _amici.ModelPtr_getParameterScale(self)

    def setParameterScale(self, *args):
        return _amici.ModelPtr_setParameterScale(self, *args)

    def getUnscaledParameters(self) -> Tuple[float]:
        """
        Get parameters with transformation according to parameter scale
        applied.
        :rtype: DoubleVector
        :return: Unscaled parameters
        """
        return _amici.ModelPtr_getUnscaledParameters(self)

    def getParameters(self) -> Tuple[float]:
        """
        Get parameter vector.
        :rtype: DoubleVector
        :return: The user-set parameters (see also `Model::getUnscaledParameters`)
        """
        return _amici.ModelPtr_getParameters(self)

    def getParameterById(self, par_id: str) -> float:
        """
        Get value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :rtype: float
        :return: Parameter value
        """
        return _amici.ModelPtr_getParameterById(self, par_id)

    def getParameterByName(self, par_name: str) -> float:
        """
        Get value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :rtype: float
        :return: Parameter value
        """
        return _amici.ModelPtr_getParameterByName(self, par_name)

    def setParameters(self, p: 'Sequence[float]'):
        """
        Set the parameter vector.
        :type p: DoubleVector
        :param p: Vector of parameters
        """
        return _amici.ModelPtr_setParameters(self, p)

    def setParameterById(self, *args):
        """
        *Overload 1:*

        Set model parameters according to the parameter IDs and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters IDs and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter IDs in p which are
            not model parameters

        |

        *Overload 2:*

        Set value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :type value: float
        :param value: Parameter value
        """
        return _amici.ModelPtr_setParameterById(self, *args)

    def setParametersByIdRegex(self, par_id_regex: str, value: float) -> int:
        """
        Set all values of model parameters with IDs matching the specified
        regular expression.
        :type par_id_regex: str
        :param par_id_regex: Parameter ID regex
        :type value: float
        :param value: Parameter value
        :rtype: int
        :return: Number of parameter IDs that matched the regex
        """
        return _amici.ModelPtr_setParametersByIdRegex(self, par_id_regex, value)

    def setParameterByName(self, *args):
        """
        *Overload 1:*

        Set value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :type value: float
        :param value: Parameter value

        |

        *Overload 2:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters

        |

        *Overload 3:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters
        """
        return _amici.ModelPtr_setParameterByName(self, *args)

    def setParametersByNameRegex(self, par_name_regex: str, value: float) -> int:
        """
        Set all values of all model parameters with names matching the
        specified regex.
        :type par_name_regex: str
        :param par_name_regex: Parameter name regex
        :type value: float
        :param value: Parameter value
        :rtype: int
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.ModelPtr_setParametersByNameRegex(self, par_name_regex, value)

    def getFixedParameters(self) -> Tuple[float]:
        """
        Get values of fixed parameters.
        :rtype: DoubleVector
        :return: Vector of fixed parameters with same ordering as in
            Model::getFixedParameterIds
        """
        return _amici.ModelPtr_getFixedParameters(self)

    def getFixedParameterById(self, par_id: str) -> float:
        """
        Get value of fixed parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :rtype: float
        :return: Parameter value
        """
        return _amici.ModelPtr_getFixedParameterById(self, par_id)

    def getFixedParameterByName(self, par_name: str) -> float:
        """
        Get value of fixed parameter with the specified name.

        If multiple parameters have the same name, the first parameter with
        matching name is returned.

        :type par_name: str
        :param par_name: Parameter name
        :rtype: float
        :return: Parameter value
        """
        return _amici.ModelPtr_getFixedParameterByName(self, par_name)

    def setFixedParameters(self, k: 'Sequence[float]'):
        """
        Set values for constants.
        :type k: DoubleVector
        :param k: Vector of fixed parameters
        """
        return _amici.ModelPtr_setFixedParameters(self, k)

    def setFixedParameterById(self, par_id: str, value: float):
        """
        Set value of first fixed parameter with the specified ID.
        :type par_id: str
        :param par_id: Fixed parameter id
        :type value: float
        :param value: Fixed parameter value
        """
        return _amici.ModelPtr_setFixedParameterById(self, par_id, value)

    def setFixedParametersByIdRegex(self, par_id_regex: str, value: float) -> int:
        """
        Set values of all fixed parameters with the ID matching the
        specified regex.
        :type par_id_regex: str
        :param par_id_regex: Fixed parameter name regex
        :type value: float
        :param value: Fixed parameter value
        :rtype: int
        :return: Number of fixed parameter IDs that matched the regex
        """
        return _amici.ModelPtr_setFixedParametersByIdRegex(self, par_id_regex, value)

    def setFixedParameterByName(self, par_name: str, value: float):
        """
        Set value of first fixed parameter with the specified name.
        :type par_name: str
        :param par_name: Fixed parameter ID
        :type value: float
        :param value: Fixed parameter value
        """
        return _amici.ModelPtr_setFixedParameterByName(self, par_name, value)

    def setFixedParametersByNameRegex(self, par_name_regex: str, value: float) -> int:
        """
        Set value of all fixed parameters with name matching the specified
        regex.
        :type par_name_regex: str
        :param par_name_regex: Fixed parameter name regex
        :type value: float
        :param value: Fixed parameter value
        :rtype: int
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.ModelPtr_setFixedParametersByNameRegex(self, par_name_regex, value)

    def getName(self) -> str:
        """
        Get the model name.
        :rtype: str
        :return: Model name
        """
        return _amici.ModelPtr_getName(self)

    def hasParameterNames(self) -> bool:
        """
        Report whether the model has parameter names set.

        :rtype: boolean
        :return: Boolean indicating whether parameter names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasParameterNames(self)

    def getParameterNames(self) -> Tuple[str]:
        """
        Get names of the model parameters.
        :rtype: StringVector
        :return: The parameter names
        """
        return _amici.ModelPtr_getParameterNames(self)

    def hasStateNames(self) -> bool:
        """
        Report whether the model has state names set.

        :rtype: boolean
        :return: Boolean indicating whether state names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasStateNames(self)

    def getStateNames(self) -> Tuple[str]:
        """
        Get names of the model states.
        :rtype: StringVector
        :return: State names
        """
        return _amici.ModelPtr_getStateNames(self)

    def getStateNamesSolver(self) -> Tuple[str]:
        """
        Get names of the solver states.
        :rtype: StringVector
        :return: State names
        """
        return _amici.ModelPtr_getStateNamesSolver(self)

    def hasFixedParameterNames(self) -> bool:
        """
        Report whether the model has fixed parameter names set.
        :rtype: boolean
        :return: Boolean indicating whether fixed parameter names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasFixedParameterNames(self)

    def getFixedParameterNames(self) -> Tuple[str]:
        """
        Get names of the fixed model parameters.
        :rtype: StringVector
        :return: Fixed parameter names
        """
        return _amici.ModelPtr_getFixedParameterNames(self)

    def hasObservableNames(self) -> bool:
        """
        Report whether the model has observable names set.
        :rtype: boolean
        :return: Boolean indicating whether observable names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasObservableNames(self)

    def getObservableNames(self) -> Tuple[str]:
        """
        Get names of the observables.
        :rtype: StringVector
        :return: Observable names
        """
        return _amici.ModelPtr_getObservableNames(self)

    def hasExpressionNames(self) -> bool:
        """
        Report whether the model has expression names set.
        :rtype: boolean
        :return: Boolean indicating whether expression names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasExpressionNames(self)

    def getExpressionNames(self) -> Tuple[str]:
        """
        Get names of the expressions.
        :rtype: StringVector
        :return: Expression names
        """
        return _amici.ModelPtr_getExpressionNames(self)

    def hasParameterIds(self) -> bool:
        """
        Report whether the model has parameter IDs set.
        :rtype: boolean
        :return: Boolean indicating whether parameter IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasParameterIds(self)

    def getParameterIds(self) -> Tuple[str]:
        """
        Get IDs of the model parameters.
        :rtype: StringVector
        :return: Parameter IDs
        """
        return _amici.ModelPtr_getParameterIds(self)

    def hasStateIds(self) -> bool:
        """
        Report whether the model has state IDs set.
        :rtype: boolean
        :return: Boolean indicating whether state IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasStateIds(self)

    def getStateIds(self) -> Tuple[str]:
        """
        Get IDs of the model states.
        :rtype: StringVector
        :return: State IDs
        """
        return _amici.ModelPtr_getStateIds(self)

    def getStateIdsSolver(self) -> Tuple[str]:
        """
        Get IDs of the solver states.
        :rtype: StringVector
        :return: State IDs
        """
        return _amici.ModelPtr_getStateIdsSolver(self)

    def hasFixedParameterIds(self) -> bool:
        """
        Report whether the model has fixed parameter IDs set.
        :rtype: boolean
        :return: Boolean indicating whether fixed parameter IDs were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasFixedParameterIds(self)

    def getFixedParameterIds(self) -> Tuple[str]:
        """
        Get IDs of the fixed model parameters.
        :rtype: StringVector
        :return: Fixed parameter IDs
        """
        return _amici.ModelPtr_getFixedParameterIds(self)

    def hasObservableIds(self) -> bool:
        """
        Report whether the model has observable IDs set.
        :rtype: boolean
        :return: Boolean indicating whether observable ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasObservableIds(self)

    def getObservableIds(self) -> Tuple[str]:
        """
        Get IDs of the observables.
        :rtype: StringVector
        :return: Observable IDs
        """
        return _amici.ModelPtr_getObservableIds(self)

    def hasExpressionIds(self) -> bool:
        """
        Report whether the model has expression IDs set.
        :rtype: boolean
        :return: Boolean indicating whether expression ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasExpressionIds(self)

    def getExpressionIds(self) -> Tuple[str]:
        """
        Get IDs of the expression.
        :rtype: StringVector
        :return: Expression IDs
        """
        return _amici.ModelPtr_getExpressionIds(self)

    def hasQuadraticLLH(self) -> bool:
        """
        Checks whether the defined noise model is gaussian, i.e., the nllh
        is quadratic
        :rtype: boolean
        :return: boolean flag
        """
        return _amici.ModelPtr_hasQuadraticLLH(self)

    def getTimepoints(self) -> Tuple[float]:
        """
        Get the timepoint vector.
        :rtype: DoubleVector
        :return: Timepoint vector
        """
        return _amici.ModelPtr_getTimepoints(self)

    def getTimepoint(self, it: int) -> float:
        """
        Get simulation timepoint for time index `it`.
        :type it: int
        :param it: Time index
        :rtype: float
        :return: Timepoint
        """
        return _amici.ModelPtr_getTimepoint(self, it)

    def setTimepoints(self, ts: 'Sequence[float]'):
        """
        Set the timepoint vector.
        :type ts: DoubleVector
        :param ts: New timepoint vector
        """
        return _amici.ModelPtr_setTimepoints(self, ts)

    def t0(self) -> float:
        """
        Get simulation start time.
        :rtype: float
        :return: Simulation start time
        """
        return _amici.ModelPtr_t0(self)

    def setT0(self, t0: float):
        """
        Set simulation start time.
        :type t0: float
        :param t0: Simulation start time
        """
        return _amici.ModelPtr_setT0(self, t0)

    def getStateIsNonNegative(self) -> Tuple[bool]:
        """
        Get flags indicating whether states should be treated as
        non-negative.
        :rtype: BoolVector
        :return: Vector of flags
        """
        return _amici.ModelPtr_getStateIsNonNegative(self)

    def setStateIsNonNegative(self, stateIsNonNegative: 'BoolVector'):
        """
        Set flags indicating whether states should be treated as
        non-negative.
        :type stateIsNonNegative: BoolVector
        :param stateIsNonNegative: Vector of flags
        """
        return _amici.ModelPtr_setStateIsNonNegative(self, stateIsNonNegative)

    def setAllStatesNonNegative(self):
        """
        Set flags indicating that all states should be treated as
        non-negative.
        """
        return _amici.ModelPtr_setAllStatesNonNegative(self)

    def setMinimumSigmaResiduals(self, min_sigma: float):
        """
        Sets the estimated lower boundary for sigma_y. When
        :meth:`setAddSigmaResiduals` is activated, this lower boundary must
        ensure that log(sigma) + min_sigma > 0.
        :type min_sigma: float
        :param min_sigma: lower boundary
        """
        return _amici.ModelPtr_setMinimumSigmaResiduals(self, min_sigma)

    def getMinimumSigmaResiduals(self) -> float:
        """
        Gets the specified estimated lower boundary for sigma_y.
        :rtype: float
        :return: lower boundary
        """
        return _amici.ModelPtr_getMinimumSigmaResiduals(self)

    def setAddSigmaResiduals(self, sigma_res: bool):
        """
        Specifies whether residuals should be added to account for
        parameter dependent sigma.

        If set to true, additional residuals of the form :math:`\\sqrt{\\log(\\sigma) +C}` will be added. This enables least-squares optimization for
        variables with Gaussian noise assumption and parameter dependent standard
        deviation sigma. The constant :math:`C` can be set via
        :meth:`setMinimumSigmaResiduals`.

        :type sigma_res: boolean
        :param sigma_res: if true, additional residuals are added
        """
        return _amici.ModelPtr_setAddSigmaResiduals(self, sigma_res)

    def getAddSigmaResiduals(self) -> bool:
        """
        Checks whether residuals should be added to account for parameter
        dependent sigma.
        :rtype: boolean
        :return: sigma_res
        """
        return _amici.ModelPtr_getAddSigmaResiduals(self)

    def getParameterList(self) -> Tuple[int]:
        """
        Get the list of parameters for which sensitivities are computed.
        :rtype: IntVector
        :return: List of parameter indices
        """
        return _amici.ModelPtr_getParameterList(self)

    def plist(self, pos: int) -> int:
        """
        Get entry in parameter list by index.
        :type pos: int
        :param pos: Index in sensitivity parameter list
        :rtype: int
        :return: Index in parameter list
        """
        return _amici.ModelPtr_plist(self, pos)

    def setParameterList(self, plist: Sequence[int]):
        """
        Set the list of parameters for which sensitivities are to be
        computed.

        NOTE: Resets initial state sensitivities.

        :type plist: IntVector
        :param plist: List of parameter indices
        """
        return _amici.ModelPtr_setParameterList(self, plist)

    def getInitialStates(self) -> Tuple[float]:
        """
        Get the initial states.
        :rtype: DoubleVector
        :return: Initial state vector
        """
        return _amici.ModelPtr_getInitialStates(self)

    def setInitialStates(self, x0: 'Sequence[float]'):
        """
        Set the initial states.
        :type x0: DoubleVector
        :param x0: Initial state vector
        """
        return _amici.ModelPtr_setInitialStates(self, x0)

    def hasCustomInitialStates(self) -> bool:
        """
        Return whether custom initial states have been set.
        :rtype: boolean
        :return: `true` if has custom initial states, otherwise `false`
        """
        return _amici.ModelPtr_hasCustomInitialStates(self)

    def getInitialStateSensitivities(self) -> Tuple[float]:
        """
        Get the initial states sensitivities.
        :rtype: DoubleVector
        :return: vector of initial state sensitivities
        """
        return _amici.ModelPtr_getInitialStateSensitivities(self)

    def setInitialStateSensitivities(self, sx0: 'Sequence[float]'):
        """
        Set the initial state sensitivities.
        :type sx0: DoubleVector
        :param sx0: vector of initial state sensitivities with chainrule applied.
            This could be a slice of ReturnData::sx or ReturnData::sx0
        """
        return _amici.ModelPtr_setInitialStateSensitivities(self, sx0)

    def hasCustomInitialStateSensitivities(self) -> bool:
        """
        Return whether custom initial state sensitivities have been set.
        :rtype: boolean
        :return: `true` if has custom initial state sensitivities, otherwise
            `false`.
        """
        return _amici.ModelPtr_hasCustomInitialStateSensitivities(self)

    def setUnscaledInitialStateSensitivities(self, sx0: 'Sequence[float]'):
        """
        Set the initial state sensitivities.
        :type sx0: DoubleVector
        :param sx0: Vector of initial state sensitivities without chainrule
            applied. This could be the readin from a `model.sx0data` saved to HDF5.
        """
        return _amici.ModelPtr_setUnscaledInitialStateSensitivities(self, sx0)

    def setSteadyStateComputationMode(self, mode: 'amici::SteadyStateComputationMode'):
        """
        Set the mode how steady state is computed in the steadystate
        simulation.
        :type mode: int
        :param mode: Steadystate computation mode
        """
        return _amici.ModelPtr_setSteadyStateComputationMode(self, mode)

    def getSteadyStateComputationMode(self) -> 'amici::SteadyStateComputationMode':
        """
        Gets the mode how steady state is computed in the steadystate
        simulation.
        :rtype: int
        :return: Mode
        """
        return _amici.ModelPtr_getSteadyStateComputationMode(self)

    def setSteadyStateSensitivityMode(self, mode: 'SteadyStateSensitivityMode'):
        """
        Set the mode how sensitivities are computed in the steadystate
        simulation.
        :type mode: SteadyStateSensitivityMode
        :param mode: Steadystate sensitivity mode
        """
        return _amici.ModelPtr_setSteadyStateSensitivityMode(self, mode)

    def getSteadyStateSensitivityMode(self) -> 'SteadyStateSensitivityMode':
        """
        Gets the mode how sensitivities are computed in the steadystate
        simulation.
        :rtype: SteadyStateSensitivityMode
        :return: Mode
        """
        return _amici.ModelPtr_getSteadyStateSensitivityMode(self)

    def setReinitializeFixedParameterInitialStates(self, flag: bool):
        """
        Set whether initial states depending on fixed parameters are to be
        reinitialized after preequilibration and presimulation.
        :type flag: boolean
        :param flag: Fixed parameters reinitialized?
        """
        return _amici.ModelPtr_setReinitializeFixedParameterInitialStates(self, flag)

    def getReinitializeFixedParameterInitialStates(self) -> bool:
        """
        Get whether initial states depending on fixedParameters are to be
        reinitialized after preequilibration and presimulation.
        :rtype: boolean
        :return: flag `true` / `false`
        """
        return _amici.ModelPtr_getReinitializeFixedParameterInitialStates(self)

    def requireSensitivitiesForAllParameters(self):
        """
        Require computation of sensitivities for all parameters p [0..np[
        in natural order.

        NOTE: Resets initial state sensitivities.
        """
        return _amici.ModelPtr_requireSensitivitiesForAllParameters(self)

    def getObservableScaling(self, iy: int) -> 'ObservableScaling':
        """
        Get scaling type for observable
        :type iy: int
        :param iy: observable index
        :rtype: int
        :return: scaling type
        """
        return _amici.ModelPtr_getObservableScaling(self, iy)

    def setAlwaysCheckFinite(self, alwaysCheck: bool):
        """
        Set whether the result of every call to `Model::f*` should be
        checked for finiteness.
        :type alwaysCheck: boolean
        :param alwaysCheck:
        """
        return _amici.ModelPtr_setAlwaysCheckFinite(self, alwaysCheck)

    def getAlwaysCheckFinite(self) -> bool:
        """
        Get setting of whether the result of every call to `Model::f*`
        should be checked for finiteness.
        :rtype: boolean
        :return: that
        """
        return _amici.ModelPtr_getAlwaysCheckFinite(self)

    def setReinitializationStateIdxs(self, idxs: Sequence[int]):
        """
        Set indices of states to be reinitialized based on provided
        constants / fixed parameters
        :type idxs: IntVector
        :param idxs: Array of state indices
        """
        return _amici.ModelPtr_setReinitializationStateIdxs(self, idxs)

    def getReinitializationStateIdxs(self) -> Tuple[int]:
        """
        Return indices of states to be reinitialized based on provided
        constants / fixed parameters
        :rtype: IntVector
        :return: Those indices.
        """
        return _amici.ModelPtr_getReinitializationStateIdxs(self)
    pythonGenerated = property(_amici.ModelPtr_pythonGenerated_get, _amici.ModelPtr_pythonGenerated_set, doc=' Flag indicating Matlab- or Python-based model generation')
    o2mode = property(_amici.ModelPtr_o2mode_get, _amici.ModelPtr_o2mode_set, doc='\n    Flag indicating whether for\n    `amici::Solver::sensi_` == `amici::SensitivityOrder::second`\n    directional or full second order derivative will be computed\n    ')
    idlist = property(_amici.ModelPtr_idlist_get, _amici.ModelPtr_idlist_set, doc=' Flag array for DAE equations')
    logger = property(_amici.ModelPtr_logger_get, _amici.ModelPtr_logger_set, doc=' Logger')

    def getSolver(self) -> 'Solver':
        """
        Retrieves the solver object
        :rtype: Solver
        :return: The Solver instance
        """
        return _amici.ModelPtr_getSolver(self)

    def getAmiciVersion(self) -> str:
        """
        Returns the AMICI version that was used to generate the model
        :rtype: str
        :return: AMICI version string
        """
        return _amici.ModelPtr_getAmiciVersion(self)

    def getAmiciCommit(self) -> str:
        """
        Returns the AMICI commit that was used to generate the model
        :rtype: str
        :return: AMICI commit string
        """
        return _amici.ModelPtr_getAmiciCommit(self)

    def isFixedParameterStateReinitializationAllowed(self) -> bool:
        """
        Function indicating whether reinitialization of states depending
        on fixed parameters is permissible
        :rtype: boolean
        :return: flag indicating whether reinitialization of states depending on
            fixed parameters is permissible
        """
        return _amici.ModelPtr_isFixedParameterStateReinitializationAllowed(self)

    def fdsigmaydy(self, dsigmaydy: 'amici::realtype *', t: 'amici::realtype const', p: 'amici::realtype const *', k: 'amici::realtype const *', y: 'amici::realtype const *'):
        """
        Model-specific implementation of fsigmay
        :type dsigmaydy: float
        :param dsigmaydy: partial derivative of standard deviation of measurements
            w.r.t. model outputs
        :type t: float
        :param t: current time
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type y: float
        :param y: model output at timepoint t
        """
        return _amici.ModelPtr_fdsigmaydy(self, dsigmaydy, t, p, k, y)

    def fdx_rdatadx_solver(self, dx_rdatadx_solver: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *'):
        """
        Compute dx_rdata / dx_solver
        :type dx_rdatadx_solver: float
        :param dx_rdatadx_solver: dx_rdata / dx_solver
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdx_rdatadx_solver(self, dx_rdatadx_solver, x, tcl, p, k)

    def fdx_rdatadp(self, dx_rdatadp: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Compute dx_rdata / dp
        :type dx_rdatadp: float
        :param dx_rdatadp: dx_rdata / dp
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdx_rdatadp(self, dx_rdatadp, x, tcl, p, k, ip)

    def fdx_rdatadtcl(self, dx_rdatadtcl: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *'):
        """
        Compute dx_rdata / dtcl
        :type dx_rdatadtcl: float
        :param dx_rdatadtcl: dx_rdata / dtcl
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdx_rdatadtcl(self, dx_rdatadtcl, x, tcl, p, k)

    def fdtotal_cldp(self, dtotal_cldp: 'amici::realtype *', x_rdata: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Compute dtotal_cl / dp
        :type dtotal_cldp: float
        :param dtotal_cldp: dtotal_cl / dp
        :type x_rdata: float
        :param x_rdata: State variables with conservation laws applied
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdtotal_cldp(self, dtotal_cldp, x_rdata, p, k, ip)

    def fdtotal_cldx_rdata(self, dtotal_cldx_rdata: 'amici::realtype *', x_rdata: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', tcl: 'amici::realtype const *'):
        """
        Compute dtotal_cl / dx_rdata
        :type dtotal_cldx_rdata: float
        :param dtotal_cldx_rdata: dtotal_cl / dx_rdata
        :type x_rdata: float
        :param x_rdata: State variables with conservation laws applied
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdtotal_cldx_rdata(self, dtotal_cldx_rdata, x_rdata, p, k, tcl)

    def fdspline_valuesdp(self, dspline_valuesdp: 'amici::realtype *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Model-specific implementation the parametric derivatives
        of spline node values
        :type dspline_valuesdp: float
        :param dspline_valuesdp: vector to which derivatives will be written
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constants vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdspline_valuesdp(self, dspline_valuesdp, p, k, ip)

    def fdspline_slopesdp(self, dspline_slopesdp: 'amici::realtype *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Model-specific implementation the parametric derivatives
        of slopevalues at spline nodes
        :type dspline_slopesdp: float
        :param dspline_slopesdp: vector to which derivatives will be written
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constants vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdspline_slopesdp(self, dspline_slopesdp, p, k, ip)
    nx_rdata = property(_amici.ModelPtr_nx_rdata_get, _amici.ModelPtr_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ModelPtr_nxtrue_rdata_get, _amici.ModelPtr_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ModelPtr_nx_solver_get, _amici.ModelPtr_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ModelPtr_nxtrue_solver_get, _amici.ModelPtr_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ModelPtr_nx_solver_reinit_get, _amici.ModelPtr_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    ny = property(_amici.ModelPtr_ny_get, _amici.ModelPtr_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ModelPtr_nytrue_get, _amici.ModelPtr_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ModelPtr_nz_get, _amici.ModelPtr_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ModelPtr_nztrue_get, _amici.ModelPtr_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ModelPtr_ne_get, _amici.ModelPtr_ne_set, doc=' Number of events')
    nspl = property(_amici.ModelPtr_nspl_get, _amici.ModelPtr_nspl_set, doc=' numer of spline functions in the model')
    nw = property(_amici.ModelPtr_nw_get, _amici.ModelPtr_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ModelPtr_ndwdx_get, _amici.ModelPtr_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ModelPtr_ndwdp_get, _amici.ModelPtr_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ModelPtr_ndwdw_get, _amici.ModelPtr_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ModelPtr_ndxdotdw_get, _amici.ModelPtr_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ModelPtr_ndJydy_get, _amici.ModelPtr_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ModelPtr_ndxrdatadxsolver_get, _amici.ModelPtr_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ModelPtr_ndxrdatadtcl_get, _amici.ModelPtr_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ModelPtr_ndtotal_cldx_rdata_get, _amici.ModelPtr_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ModelPtr_nnz_get, _amici.ModelPtr_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ModelPtr_nJ_get, _amici.ModelPtr_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ModelPtr_ubw_get, _amici.ModelPtr_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ModelPtr_lbw_get, _amici.ModelPtr_lbw_set, doc=' Lower bandwidth of the Jacobian')
_amici.ModelPtr_swigregister(ModelPtr)

class ExpDataPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ExpDataPtr_swiginit(self, _amici.new_ExpDataPtr(*args))

    def __deref__(self) -> 'std::unique_ptr< amici::ExpData >::pointer':
        return _amici.ExpDataPtr___deref__(self)

    def release(self) -> 'std::unique_ptr< amici::ExpData >::pointer':
        return _amici.ExpDataPtr_release(self)

    def reset(self, *args):
        return _amici.ExpDataPtr_reset(self, *args)

    def swap(self, __u: 'ExpDataPtr'):
        return _amici.ExpDataPtr_swap(self, __u)

    def get(self) -> 'std::unique_ptr< amici::ExpData >::pointer':
        return _amici.ExpDataPtr_get(self)

    def __nonzero__(self):
        return _amici.ExpDataPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ExpDataPtr

    def __repr__(self):
        return _edata_repr(self)

    def nytrue(self) -> int:
        """
        number of observables of the non-augmented model

        :rtype: int
        :return: number of observables of the non-augmented model
        """
        return _amici.ExpDataPtr_nytrue(self)

    def nztrue(self) -> int:
        """
        number of event observables of the non-augmented model

        :rtype: int
        :return: number of event observables of the non-augmented model
        """
        return _amici.ExpDataPtr_nztrue(self)

    def nmaxevent(self) -> int:
        """
        maximal number of events to track

        :rtype: int
        :return: maximal number of events to track
        """
        return _amici.ExpDataPtr_nmaxevent(self)

    def nt(self) -> int:
        """
        number of timepoints

        :rtype: int
        :return: number of timepoints
        """
        return _amici.ExpDataPtr_nt(self)

    def setTimepoints(self, ts: 'Sequence[float]'):
        """
        Set output timepoints.

        :type ts: DoubleVector
        :param ts: timepoints
        """
        return _amici.ExpDataPtr_setTimepoints(self, ts)

    def getTimepoints(self) -> Tuple[float]:
        """
        Get output timepoints.

        :rtype: DoubleVector
        :return: ExpData::ts
        """
        return _amici.ExpDataPtr_getTimepoints(self)

    def getTimepoint(self, it: int) -> float:
        """
        Get timepoint for the given index

        :type it: int
        :param it: timepoint index

        :rtype: float
        :return: timepoint timepoint at index
        """
        return _amici.ExpDataPtr_getTimepoint(self, it)

    def setObservedData(self, *args):
        """
        *Overload 1:*

        Set all measurements.

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)

        |

        *Overload 2:*

        Set measurements for a given observable index

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpDataPtr_setObservedData(self, *args)

    def isSetObservedData(self, it: int, iy: int) -> bool:
        """
        Whether there is a measurement for the given time- and observable-
        index.

        :type it: int
        :param it: time index
        :type iy: int
        :param iy: observable index

        :rtype: boolean
        :return: boolean specifying if data was set
        """
        return _amici.ExpDataPtr_isSetObservedData(self, it, iy)

    def getObservedData(self) -> Tuple[float]:
        """
        Get all measurements.

        :rtype: DoubleVector
        :return: observed data (dimension: nt x nytrue, row-major)
        """
        return _amici.ExpDataPtr_getObservedData(self)

    def getObservedDataPtr(self, it: int) -> 'amici::realtype const *':
        """
        Get measurements for a given timepoint index.

        :type it: int
        :param it: timepoint index

        :rtype: float
        :return: pointer to observed data at index (dimension: nytrue)
        """
        return _amici.ExpDataPtr_getObservedDataPtr(self, it)

    def setObservedDataStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviations for measurements.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt x nytrue, row-major)

        |

        *Overload 2:*

        Set indentical standard deviation for all measurements.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviations of observed data for a
        specific observable index.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt)
        :type iy: int
        :param iy: observed data index

        |

        *Overload 4:*

        Set all standard deviation for a given observable index to the
        input value.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpDataPtr_setObservedDataStdDev(self, *args)

    def isSetObservedDataStdDev(self, it: int, iy: int) -> bool:
        """
        Whether standard deviation for a measurement at
        specified timepoint- and observable index has been set.

        :type it: int
        :param it: time index
        :type iy: int
        :param iy: observable index
        :rtype: boolean
        :return: boolean specifying if standard deviation of data was set
        """
        return _amici.ExpDataPtr_isSetObservedDataStdDev(self, it, iy)

    def getObservedDataStdDev(self) -> Tuple[float]:
        """
        Get measurement standard deviations.

        :rtype: DoubleVector
        :return: standard deviation of observed data
        """
        return _amici.ExpDataPtr_getObservedDataStdDev(self)

    def getObservedDataStdDevPtr(self, it: int) -> 'amici::realtype const *':
        """
        Get pointer to measurement standard deviations.

        :type it: int
        :param it: timepoint index
        :rtype: float
        :return: pointer to standard deviation of observed data at index
        """
        return _amici.ExpDataPtr_getObservedDataStdDevPtr(self, it)

    def setObservedEvents(self, *args):
        """
        *Overload 1:*

        set function that copies observed event data from input to
        ExpData::observedEvents

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent x nztrue,
            row-major)

        |

        *Overload 2:*

        set function that copies observed event data for specific event
        observable

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent)
        :type iz: int
        :param iz: observed event data index
        """
        return _amici.ExpDataPtr_setObservedEvents(self, *args)

    def isSetObservedEvents(self, ie: int, iz: int) -> bool:
        """
        get function that checks whether event data at specified indices
        has been set

        :type ie: int
        :param ie: event index
        :type iz: int
        :param iz: event observable index
        :rtype: boolean
        :return: boolean specifying if data was set
        """
        return _amici.ExpDataPtr_isSetObservedEvents(self, ie, iz)

    def getObservedEvents(self) -> Tuple[float]:
        """
        get function that copies data from ExpData::mz to output

        :rtype: DoubleVector
        :return: observed event data
        """
        return _amici.ExpDataPtr_getObservedEvents(self)

    def getObservedEventsPtr(self, ie: int) -> 'amici::realtype const *':
        """
        get function that returns a pointer to observed data at ieth
        occurrence

        :type ie: int
        :param ie: event occurrence

        :rtype: float
        :return: pointer to observed event data at ieth occurrence
        """
        return _amici.ExpDataPtr_getObservedEventsPtr(self, ie)

    def setObservedEventsStdDev(self, *args):
        """
        *Overload 1:*

        set function that copies data from input to
        ExpData::observedEventsStdDev

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed event data

        |

        *Overload 2:*

        set function that sets all ExpData::observedDataStdDev to the
        input value

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        set function that copies standard deviation of observed data for
        specific observable

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed data
            (dimension: nmaxevent)
        :type iz: int
        :param iz: observed data index

        |

        *Overload 4:*

        set function that sets all standard deviation of a specific
        observable to the input value

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iz: int
        :param iz: observed data index
        """
        return _amici.ExpDataPtr_setObservedEventsStdDev(self, *args)

    def isSetObservedEventsStdDev(self, ie: int, iz: int) -> bool:
        """
        get function that checks whether standard deviation of even data
        at specified indices has been set

        :type ie: int
        :param ie: event index
        :type iz: int
        :param iz: event observable index
        :rtype: boolean
        :return: boolean specifying if standard deviation of event data was set
        """
        return _amici.ExpDataPtr_isSetObservedEventsStdDev(self, ie, iz)

    def getObservedEventsStdDev(self) -> Tuple[float]:
        """
        get function that copies data from ExpData::observedEventsStdDev
        to output

        :rtype: DoubleVector
        :return: standard deviation of observed event data
        """
        return _amici.ExpDataPtr_getObservedEventsStdDev(self)

    def getObservedEventsStdDevPtr(self, ie: int) -> 'amici::realtype const *':
        """
        get function that returns a pointer to standard deviation of
        observed event data at ie-th occurrence

        :type ie: int
        :param ie: event occurrence

        :rtype: float
        :return: pointer to standard deviation of observed event data at ie-th
            occurrence
        """
        return _amici.ExpDataPtr_getObservedEventsStdDevPtr(self, ie)
    id = property(_amici.ExpDataPtr_id_get, _amici.ExpDataPtr_id_set, doc='Arbitrary (not necessarily unique) identifier.')

    def reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        presimulation (only meaningful if preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        the 'main' simulation (only meaningful if presimulation or
        preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        all simulation phases.

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata)
    fixedParameters = property(_amici.ExpDataPtr_fixedParameters_get, _amici.ExpDataPtr_fixedParameters_set, doc='\n    Model constants\n\n    Vector of size Model::nk() or empty\n    ')
    fixedParametersPreequilibration = property(_amici.ExpDataPtr_fixedParametersPreequilibration_get, _amici.ExpDataPtr_fixedParametersPreequilibration_set, doc='\n    Model constants for pre-equilibration\n\n    Vector of size Model::nk() or empty.\n    ')
    fixedParametersPresimulation = property(_amici.ExpDataPtr_fixedParametersPresimulation_get, _amici.ExpDataPtr_fixedParametersPresimulation_set, doc='\n    Model constants for pre-simulation\n\n    Vector of size Model::nk() or empty.\n    ')
    parameters = property(_amici.ExpDataPtr_parameters_get, _amici.ExpDataPtr_parameters_set, doc='\n    Model parameters\n\n    Vector of size Model::np() or empty with parameter scaled according to\n    SimulationParameter::pscale.\n    ')
    x0 = property(_amici.ExpDataPtr_x0_get, _amici.ExpDataPtr_x0_set, doc='\n    Initial state\n\n    Vector of size Model::nx() or empty\n    ')
    sx0 = property(_amici.ExpDataPtr_sx0_get, _amici.ExpDataPtr_sx0_set, doc='\n    Initial state sensitivities\n\n    Dimensions:\n    Model::nx() * Model::nplist(), Model::nx() * ExpData::plist.size(), if\n    ExpData::plist is not empty, or empty\n    ')
    pscale = property(_amici.ExpDataPtr_pscale_get, _amici.ExpDataPtr_pscale_set, doc='\n    Parameter scales\n\n    Vector of parameter scale of size Model::np(), indicating how/if each\n    parameter is to be scaled.\n    ')
    plist = property(_amici.ExpDataPtr_plist_get, _amici.ExpDataPtr_plist_set, doc='Parameter indices w.r.t. which to compute sensitivities')
    tstart_ = property(_amici.ExpDataPtr_tstart__get, _amici.ExpDataPtr_tstart__set, doc=' starting time')
    t_presim = property(_amici.ExpDataPtr_t_presim_get, _amici.ExpDataPtr_t_presim_set, doc='\n    Duration of pre-simulation.\n\n    If this is > 0, presimulation will be performed from\n    (model->t0 - t_presim) to model->t0 using the fixedParameters in\n    fixedParametersPresimulation\n    ')
    ts_ = property(_amici.ExpDataPtr_ts__get, _amici.ExpDataPtr_ts__set, doc='\n    Timepoints for which model state/outputs/... are requested\n\n    Vector of timepoints.\n    ')
    reinitializeFixedParameterInitialStates = property(_amici.ExpDataPtr_reinitializeFixedParameterInitialStates_get, _amici.ExpDataPtr_reinitializeFixedParameterInitialStates_set, doc='\n    Flag indicating whether reinitialization of states depending on\n    fixed parameters is activated\n    ')
    reinitialization_state_idxs_presim = property(_amici.ExpDataPtr_reinitialization_state_idxs_presim_get, _amici.ExpDataPtr_reinitialization_state_idxs_presim_set, doc='\n    Indices of states to be reinitialized based on provided\n    presimulation constants / fixed parameters.\n    ')
    reinitialization_state_idxs_sim = property(_amici.ExpDataPtr_reinitialization_state_idxs_sim_get, _amici.ExpDataPtr_reinitialization_state_idxs_sim_set, doc='\n    Indices of states to be reinitialized based on provided\n    constants / fixed parameters.\n    ')
_amici.ExpDataPtr_swigregister(ExpDataPtr)
M_E = _amici.M_E
M_LOG2E = _amici.M_LOG2E
M_LOG10E = _amici.M_LOG10E
M_LN2 = _amici.M_LN2
M_LN10 = _amici.M_LN10
M_PI = _amici.M_PI
M_PI_2 = _amici.M_PI_2
M_PI_4 = _amici.M_PI_4
M_1_PI = _amici.M_1_PI
M_2_PI = _amici.M_2_PI
M_2_SQRTPI = _amici.M_2_SQRTPI
M_SQRT2 = _amici.M_SQRT2
M_SQRT1_2 = _amici.M_SQRT1_2
BLASLayout_rowMajor = _amici.BLASLayout_rowMajor
BLASLayout_colMajor = _amici.BLASLayout_colMajor
BLASTranspose_noTrans = _amici.BLASTranspose_noTrans
BLASTranspose_trans = _amici.BLASTranspose_trans
BLASTranspose_conjTrans = _amici.BLASTranspose_conjTrans
ParameterScaling_none = _amici.ParameterScaling_none
ParameterScaling_ln = _amici.ParameterScaling_ln
ParameterScaling_log10 = _amici.ParameterScaling_log10
ObservableScaling_lin = _amici.ObservableScaling_lin
ObservableScaling_log = _amici.ObservableScaling_log
ObservableScaling_log10 = _amici.ObservableScaling_log10
SecondOrderMode_none = _amici.SecondOrderMode_none
SecondOrderMode_full = _amici.SecondOrderMode_full
SecondOrderMode_directional = _amici.SecondOrderMode_directional
SensitivityOrder_none = _amici.SensitivityOrder_none
" Don't compute sensitivities."
SensitivityOrder_first = _amici.SensitivityOrder_first
' First-order sensitivities.'
SensitivityOrder_second = _amici.SensitivityOrder_second
' Second-order sensitivities.'
SensitivityMethod_none = _amici.SensitivityMethod_none
" Don't compute sensitivities."
SensitivityMethod_forward = _amici.SensitivityMethod_forward
' Forward sensitivity analysis.'
SensitivityMethod_adjoint = _amici.SensitivityMethod_adjoint
' Adjoint sensitivity analysis.'
LinearSolver_dense = _amici.LinearSolver_dense
LinearSolver_band = _amici.LinearSolver_band
LinearSolver_LAPACKDense = _amici.LinearSolver_LAPACKDense
LinearSolver_LAPACKBand = _amici.LinearSolver_LAPACKBand
LinearSolver_diag = _amici.LinearSolver_diag
LinearSolver_SPGMR = _amici.LinearSolver_SPGMR
LinearSolver_SPBCG = _amici.LinearSolver_SPBCG
LinearSolver_SPTFQMR = _amici.LinearSolver_SPTFQMR
LinearSolver_KLU = _amici.LinearSolver_KLU
LinearSolver_SuperLUMT = _amici.LinearSolver_SuperLUMT
InternalSensitivityMethod_simultaneous = _amici.InternalSensitivityMethod_simultaneous
InternalSensitivityMethod_staggered = _amici.InternalSensitivityMethod_staggered
InternalSensitivityMethod_staggered1 = _amici.InternalSensitivityMethod_staggered1
InterpolationType_hermite = _amici.InterpolationType_hermite
InterpolationType_polynomial = _amici.InterpolationType_polynomial
LinearMultistepMethod_adams = _amici.LinearMultistepMethod_adams
LinearMultistepMethod_BDF = _amici.LinearMultistepMethod_BDF
NonlinearSolverIteration_functional = _amici.NonlinearSolverIteration_functional
NonlinearSolverIteration_fixedpoint = _amici.NonlinearSolverIteration_fixedpoint
' deprecated'
NonlinearSolverIteration_newton = _amici.NonlinearSolverIteration_newton
SteadyStateComputationMode_newtonOnly = _amici.SteadyStateComputationMode_newtonOnly
SteadyStateComputationMode_integrationOnly = _amici.SteadyStateComputationMode_integrationOnly
SteadyStateComputationMode_integrateIfNewtonFails = _amici.SteadyStateComputationMode_integrateIfNewtonFails
SteadyStateSensitivityMode_newtonOnly = _amici.SteadyStateSensitivityMode_newtonOnly
SteadyStateSensitivityMode_integrationOnly = _amici.SteadyStateSensitivityMode_integrationOnly
SteadyStateSensitivityMode_integrateIfNewtonFails = _amici.SteadyStateSensitivityMode_integrateIfNewtonFails
SteadyStateStatus_failed_too_long_simulation = _amici.SteadyStateStatus_failed_too_long_simulation
SteadyStateStatus_failed_damping = _amici.SteadyStateStatus_failed_damping
SteadyStateStatus_failed_factorization = _amici.SteadyStateStatus_failed_factorization
SteadyStateStatus_failed_convergence = _amici.SteadyStateStatus_failed_convergence
SteadyStateStatus_failed = _amici.SteadyStateStatus_failed
SteadyStateStatus_not_run = _amici.SteadyStateStatus_not_run
SteadyStateStatus_success = _amici.SteadyStateStatus_success
SteadyStateContext_newtonSensi = _amici.SteadyStateContext_newtonSensi
SteadyStateContext_sensiStorage = _amici.SteadyStateContext_sensiStorage
SteadyStateContext_solverCreation = _amici.SteadyStateContext_solverCreation
NewtonDampingFactorMode_off = _amici.NewtonDampingFactorMode_off
NewtonDampingFactorMode_on = _amici.NewtonDampingFactorMode_on
FixedParameterContext_simulation = _amici.FixedParameterContext_simulation
FixedParameterContext_preequilibration = _amici.FixedParameterContext_preequilibration
FixedParameterContext_presimulation = _amici.FixedParameterContext_presimulation
RDataReporting_full = _amici.RDataReporting_full
RDataReporting_residuals = _amici.RDataReporting_residuals
RDataReporting_likelihood = _amici.RDataReporting_likelihood
SplineBoundaryCondition_given = _amici.SplineBoundaryCondition_given
SplineBoundaryCondition_zeroDerivative = _amici.SplineBoundaryCondition_zeroDerivative
SplineBoundaryCondition_natural = _amici.SplineBoundaryCondition_natural
SplineBoundaryCondition_naturalZeroDerivative = _amici.SplineBoundaryCondition_naturalZeroDerivative
SplineBoundaryCondition_periodic = _amici.SplineBoundaryCondition_periodic
SplineExtrapolation_noExtrapolation = _amici.SplineExtrapolation_noExtrapolation
SplineExtrapolation_constant = _amici.SplineExtrapolation_constant
SplineExtrapolation_linear = _amici.SplineExtrapolation_linear
SplineExtrapolation_polynomial = _amici.SplineExtrapolation_polynomial
SplineExtrapolation_periodic = _amici.SplineExtrapolation_periodic

class ModelDimensions(object):
    """
    Container for model dimensions.

    Holds number of states, observables, etc.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*
         Default ctor

        |

        *Overload 2:*

        Constructor with model dimensions
        :type nx_rdata: int
        :param nx_rdata: Number of state variables
        :type nxtrue_rdata: int
        :param nxtrue_rdata: Number of state variables of the non-augmented model
        :type nx_solver: int
        :param nx_solver: Number of state variables with conservation laws applied
        :type nxtrue_solver: int
        :param nxtrue_solver: Number of state variables of the non-augmented model
            with conservation laws applied
        :type nx_solver_reinit: int
        :param nx_solver_reinit: Number of state variables with conservation laws
            subject to reinitialization
        :type np: int
        :param np: Number of parameters
        :type nk: int
        :param nk: Number of constants
        :type ny: int
        :param ny: Number of observables
        :type nytrue: int
        :param nytrue: Number of observables of the non-augmented model
        :type nz: int
        :param nz: Number of event observables
        :type nztrue: int
        :param nztrue: Number of event observables of the non-augmented model
        :type ne: int
        :param ne: Number of events
        :type nspl: int
        :param nspl: Number of splines
        :type nJ: int
        :param nJ: Number of objective functions
        :type nw: int
        :param nw: Number of repeating elements
        :type ndwdx: int
        :param ndwdx: Number of nonzero elements in the `x` derivative of the
            repeating elements
        :type ndwdp: int
        :param ndwdp: Number of nonzero elements in the `p` derivative of the
            repeating elements
        :type ndwdw: int
        :param ndwdw: Number of nonzero elements in the `w` derivative of the
            repeating elements
        :type ndxdotdw: int
        :param ndxdotdw: Number of nonzero elements in the :math:`w` derivative of
            :math:`xdot`
        :type ndJydy: IntVector
        :param ndJydy: Number of nonzero elements in the :math:`y` derivative of
            :math:`dJy` (shape `nytrue`)
        :type ndxrdatadxsolver: int
        :param ndxrdatadxsolver: Number of nonzero elements in the :math:`x`
            derivative of :math:`x_rdata`
        :type ndxrdatadtcl: int
        :param ndxrdatadtcl: Number of nonzero elements in the :math:`tcl`
            derivative of :math:`x_rdata`
        :type ndtotal_cldx_rdata: int
        :param ndtotal_cldx_rdata: Number of nonzero elements in the
            :math:`x_rdata`  derivative of :math:`total_cl`
        :type nnz: int
        :param nnz: Number of nonzero elements in Jacobian
        :type ubw: int
        :param ubw: Upper matrix bandwidth in the Jacobian
        :type lbw: int
        :param lbw: Lower matrix bandwidth in the Jacobian
        """
        _amici.ModelDimensions_swiginit(self, _amici.new_ModelDimensions(*args))
    nx_rdata = property(_amici.ModelDimensions_nx_rdata_get, _amici.ModelDimensions_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ModelDimensions_nxtrue_rdata_get, _amici.ModelDimensions_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ModelDimensions_nx_solver_get, _amici.ModelDimensions_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ModelDimensions_nxtrue_solver_get, _amici.ModelDimensions_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ModelDimensions_nx_solver_reinit_get, _amici.ModelDimensions_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    np = property(_amici.ModelDimensions_np_get, _amici.ModelDimensions_np_set, doc=' Number of parameters')
    nk = property(_amici.ModelDimensions_nk_get, _amici.ModelDimensions_nk_set, doc=' Number of constants')
    ny = property(_amici.ModelDimensions_ny_get, _amici.ModelDimensions_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ModelDimensions_nytrue_get, _amici.ModelDimensions_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ModelDimensions_nz_get, _amici.ModelDimensions_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ModelDimensions_nztrue_get, _amici.ModelDimensions_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ModelDimensions_ne_get, _amici.ModelDimensions_ne_set, doc=' Number of events')
    nspl = property(_amici.ModelDimensions_nspl_get, _amici.ModelDimensions_nspl_set, doc=' numer of spline functions in the model')
    nw = property(_amici.ModelDimensions_nw_get, _amici.ModelDimensions_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ModelDimensions_ndwdx_get, _amici.ModelDimensions_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ModelDimensions_ndwdp_get, _amici.ModelDimensions_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ModelDimensions_ndwdw_get, _amici.ModelDimensions_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ModelDimensions_ndxdotdw_get, _amici.ModelDimensions_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ModelDimensions_ndJydy_get, _amici.ModelDimensions_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ModelDimensions_ndxrdatadxsolver_get, _amici.ModelDimensions_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ModelDimensions_ndxrdatadtcl_get, _amici.ModelDimensions_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ModelDimensions_ndtotal_cldx_rdata_get, _amici.ModelDimensions_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ModelDimensions_nnz_get, _amici.ModelDimensions_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ModelDimensions_nJ_get, _amici.ModelDimensions_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ModelDimensions_ubw_get, _amici.ModelDimensions_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ModelDimensions_lbw_get, _amici.ModelDimensions_lbw_set, doc=' Lower bandwidth of the Jacobian')
    __swig_destroy__ = _amici.delete_ModelDimensions
_amici.ModelDimensions_swigregister(ModelDimensions)
cvar = _amici.cvar
pi = cvar.pi
AMICI_ONEOUTPUT = cvar.AMICI_ONEOUTPUT
AMICI_RECOVERABLE_ERROR = cvar.AMICI_RECOVERABLE_ERROR
AMICI_UNRECOVERABLE_ERROR = cvar.AMICI_UNRECOVERABLE_ERROR
AMICI_TOO_MUCH_WORK = cvar.AMICI_TOO_MUCH_WORK
AMICI_TOO_MUCH_ACC = cvar.AMICI_TOO_MUCH_ACC
AMICI_ERR_FAILURE = cvar.AMICI_ERR_FAILURE
AMICI_CONV_FAILURE = cvar.AMICI_CONV_FAILURE
AMICI_RHSFUNC_FAIL = cvar.AMICI_RHSFUNC_FAIL
AMICI_FIRST_RHSFUNC_ERR = cvar.AMICI_FIRST_RHSFUNC_ERR
AMICI_ILL_INPUT = cvar.AMICI_ILL_INPUT
AMICI_ERROR = cvar.AMICI_ERROR
AMICI_NO_STEADY_STATE = cvar.AMICI_NO_STEADY_STATE
AMICI_DAMPING_FACTOR_ERROR = cvar.AMICI_DAMPING_FACTOR_ERROR
AMICI_SINGULAR_JACOBIAN = cvar.AMICI_SINGULAR_JACOBIAN
AMICI_NOT_IMPLEMENTED = cvar.AMICI_NOT_IMPLEMENTED
AMICI_MAX_TIME_EXCEEDED = cvar.AMICI_MAX_TIME_EXCEEDED
AMICI_NOT_RUN = cvar.AMICI_NOT_RUN
AMICI_SUCCESS = cvar.AMICI_SUCCESS
AMICI_DATA_RETURN = cvar.AMICI_DATA_RETURN
AMICI_ROOT_RETURN = cvar.AMICI_ROOT_RETURN
AMICI_NORMAL = cvar.AMICI_NORMAL
AMICI_ONE_STEP = cvar.AMICI_ONE_STEP
AMICI_PREEQUILIBRATE = cvar.AMICI_PREEQUILIBRATE

class SimulationParameters(object):
    """Container for various simulation parameters."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Constructor
        :type timepoints: DoubleVector
        :param timepoints: Timepoints for which simulation results are requested

        |

        *Overload 2:*

        Constructor
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants
        :type parameters: DoubleVector
        :param parameters: Model parameters

        |

        *Overload 3:*

        Constructor
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants
        :type parameters: DoubleVector
        :param parameters: Model parameters
        :type plist: IntVector
        :param plist: Model parameter indices w.r.t. which sensitivities are to be
            computed

        |

        *Overload 4:*

        Constructor
        :type timepoints: DoubleVector
        :param timepoints: Timepoints for which simulation results are requested
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants
        :type parameters: DoubleVector
        :param parameters: Model parameters
        """
        _amici.SimulationParameters_swiginit(self, _amici.new_SimulationParameters(*args))

    def reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        presimulation (only meaningful if preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        the 'main' simulation (only meaningful if presimulation or
        preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        all simulation phases.

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :type nx_rdata: int
        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata)
    fixedParameters = property(_amici.SimulationParameters_fixedParameters_get, _amici.SimulationParameters_fixedParameters_set, doc='\n    Model constants\n\n    Vector of size Model::nk() or empty\n    ')
    fixedParametersPreequilibration = property(_amici.SimulationParameters_fixedParametersPreequilibration_get, _amici.SimulationParameters_fixedParametersPreequilibration_set, doc='\n    Model constants for pre-equilibration\n\n    Vector of size Model::nk() or empty.\n    ')
    fixedParametersPresimulation = property(_amici.SimulationParameters_fixedParametersPresimulation_get, _amici.SimulationParameters_fixedParametersPresimulation_set, doc='\n    Model constants for pre-simulation\n\n    Vector of size Model::nk() or empty.\n    ')
    parameters = property(_amici.SimulationParameters_parameters_get, _amici.SimulationParameters_parameters_set, doc='\n    Model parameters\n\n    Vector of size Model::np() or empty with parameter scaled according to\n    SimulationParameter::pscale.\n    ')
    x0 = property(_amici.SimulationParameters_x0_get, _amici.SimulationParameters_x0_set, doc='\n    Initial state\n\n    Vector of size Model::nx() or empty\n    ')
    sx0 = property(_amici.SimulationParameters_sx0_get, _amici.SimulationParameters_sx0_set, doc='\n    Initial state sensitivities\n\n    Dimensions:\n    Model::nx() * Model::nplist(), Model::nx() * ExpData::plist.size(), if\n    ExpData::plist is not empty, or empty\n    ')
    pscale = property(_amici.SimulationParameters_pscale_get, _amici.SimulationParameters_pscale_set, doc='\n    Parameter scales\n\n    Vector of parameter scale of size Model::np(), indicating how/if each\n    parameter is to be scaled.\n    ')
    plist = property(_amici.SimulationParameters_plist_get, _amici.SimulationParameters_plist_set, doc='Parameter indices w.r.t. which to compute sensitivities')
    tstart_ = property(_amici.SimulationParameters_tstart__get, _amici.SimulationParameters_tstart__set, doc=' starting time')
    t_presim = property(_amici.SimulationParameters_t_presim_get, _amici.SimulationParameters_t_presim_set, doc='\n    Duration of pre-simulation.\n\n    If this is > 0, presimulation will be performed from\n    (model->t0 - t_presim) to model->t0 using the fixedParameters in\n    fixedParametersPresimulation\n    ')
    ts_ = property(_amici.SimulationParameters_ts__get, _amici.SimulationParameters_ts__set, doc='\n    Timepoints for which model state/outputs/... are requested\n\n    Vector of timepoints.\n    ')
    reinitializeFixedParameterInitialStates = property(_amici.SimulationParameters_reinitializeFixedParameterInitialStates_get, _amici.SimulationParameters_reinitializeFixedParameterInitialStates_set, doc='\n    Flag indicating whether reinitialization of states depending on\n    fixed parameters is activated\n    ')
    reinitialization_state_idxs_presim = property(_amici.SimulationParameters_reinitialization_state_idxs_presim_get, _amici.SimulationParameters_reinitialization_state_idxs_presim_set, doc='\n    Indices of states to be reinitialized based on provided\n    presimulation constants / fixed parameters.\n    ')
    reinitialization_state_idxs_sim = property(_amici.SimulationParameters_reinitialization_state_idxs_sim_get, _amici.SimulationParameters_reinitialization_state_idxs_sim_set, doc='\n    Indices of states to be reinitialized based on provided\n    constants / fixed parameters.\n    ')
    __swig_destroy__ = _amici.delete_SimulationParameters
_amici.SimulationParameters_swigregister(SimulationParameters)

class AbstractModel(object):
    """
    Abstract base class of amici::Model defining functions that need to
    be implemented in an AMICI model.

    Some functions have empty default implementations or throw.
    This class shall not have any data members.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_AbstractModel

    def getSolver(self) -> 'Solver':
        """
        Retrieves the solver object
        :rtype: Solver
        :return: The Solver instance
        """
        return _amici.AbstractModel_getSolver(self)

    def getAmiciVersion(self) -> str:
        """
        Returns the AMICI version that was used to generate the model
        :rtype: str
        :return: AMICI version string
        """
        return _amici.AbstractModel_getAmiciVersion(self)

    def getAmiciCommit(self) -> str:
        """
        Returns the AMICI commit that was used to generate the model
        :rtype: str
        :return: AMICI commit string
        """
        return _amici.AbstractModel_getAmiciCommit(self)

    def isFixedParameterStateReinitializationAllowed(self) -> bool:
        """
        Function indicating whether reinitialization of states depending
        on fixed parameters is permissible
        :rtype: boolean
        :return: flag indicating whether reinitialization of states depending on
            fixed parameters is permissible
        """
        return _amici.AbstractModel_isFixedParameterStateReinitializationAllowed(self)

    def fdsigmaydy(self, dsigmaydy: 'amici::realtype *', t: 'amici::realtype const', p: 'amici::realtype const *', k: 'amici::realtype const *', y: 'amici::realtype const *'):
        """
        Model-specific implementation of fsigmay
        :type dsigmaydy: float
        :param dsigmaydy: partial derivative of standard deviation of measurements
            w.r.t. model outputs
        :type t: float
        :param t: current time
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type y: float
        :param y: model output at timepoint t
        """
        return _amici.AbstractModel_fdsigmaydy(self, dsigmaydy, t, p, k, y)

    def fdx_rdatadx_solver(self, dx_rdatadx_solver: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *'):
        """
        Compute dx_rdata / dx_solver
        :type dx_rdatadx_solver: float
        :param dx_rdatadx_solver: dx_rdata / dx_solver
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdx_rdatadx_solver(self, dx_rdatadx_solver, x, tcl, p, k)

    def fdx_rdatadp(self, dx_rdatadp: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Compute dx_rdata / dp
        :type dx_rdatadp: float
        :param dx_rdatadp: dx_rdata / dp
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdx_rdatadp(self, dx_rdatadp, x, tcl, p, k, ip)

    def fdx_rdatadtcl(self, dx_rdatadtcl: 'amici::realtype *', x: 'amici::realtype const *', tcl: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *'):
        """
        Compute dx_rdata / dtcl
        :type dx_rdatadtcl: float
        :param dx_rdatadtcl: dx_rdata / dtcl
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type x: float
        :param x: State variables with conservation laws applied
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdx_rdatadtcl(self, dx_rdatadtcl, x, tcl, p, k)

    def fdtotal_cldp(self, dtotal_cldp: 'amici::realtype *', x_rdata: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Compute dtotal_cl / dp
        :type dtotal_cldp: float
        :param dtotal_cldp: dtotal_cl / dp
        :type x_rdata: float
        :param x_rdata: State variables with conservation laws applied
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdtotal_cldp(self, dtotal_cldp, x_rdata, p, k, ip)

    def fdtotal_cldx_rdata(self, dtotal_cldx_rdata: 'amici::realtype *', x_rdata: 'amici::realtype const *', p: 'amici::realtype const *', k: 'amici::realtype const *', tcl: 'amici::realtype const *'):
        """
        Compute dtotal_cl / dx_rdata
        :type dtotal_cldx_rdata: float
        :param dtotal_cldx_rdata: dtotal_cl / dx_rdata
        :type x_rdata: float
        :param x_rdata: State variables with conservation laws applied
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constant vector
        :type tcl: float
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdtotal_cldx_rdata(self, dtotal_cldx_rdata, x_rdata, p, k, tcl)

    def fdspline_valuesdp(self, dspline_valuesdp: 'amici::realtype *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Model-specific implementation the parametric derivatives
        of spline node values
        :type dspline_valuesdp: float
        :param dspline_valuesdp: vector to which derivatives will be written
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constants vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdspline_valuesdp(self, dspline_valuesdp, p, k, ip)

    def fdspline_slopesdp(self, dspline_slopesdp: 'amici::realtype *', p: 'amici::realtype const *', k: 'amici::realtype const *', ip: 'int const'):
        """
        Model-specific implementation the parametric derivatives
        of slopevalues at spline nodes
        :type dspline_slopesdp: float
        :param dspline_slopesdp: vector to which derivatives will be written
        :type p: float
        :param p: parameter vector
        :type k: float
        :param k: constants vector
        :type ip: int
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdspline_slopesdp(self, dspline_slopesdp, p, k, ip)
_amici.AbstractModel_swigregister(AbstractModel)

def unscaleParameters(bufferScaled: 'gsl::span< amici::realtype const >', pscale: 'gsl::span< amici::ParameterScaling const >', bufferUnscaled: 'gsl::span< amici::realtype >'):
    """
    Remove parameter scaling according to the parameter scaling in pscale

    All vectors must be of same length.

    :type bufferScaled: gsl::span< amici::realtype const >
    :param bufferScaled: scaled parameters
    :type pscale: gsl::span< amici::ParameterScaling const >
    :param pscale: parameter scaling
    :type bufferUnscaled: gsl::span< amici::realtype >
    :param bufferUnscaled: unscaled parameters are written to the array
    """
    return _amici.unscaleParameters(bufferScaled, pscale, bufferUnscaled)

def getUnscaledParameter(scaledParameter: float, scaling: 'ParameterScaling') -> float:
    """
    Remove parameter scaling according to `scaling`

    :type scaledParameter: float
    :param scaledParameter: scaled parameter
    :type scaling: int
    :param scaling: parameter scaling

    :rtype: float
    :return: Unscaled parameter
    """
    return _amici.getUnscaledParameter(scaledParameter, scaling)

def getScaledParameter(unscaledParameter: float, scaling: 'ParameterScaling') -> float:
    """
    Apply parameter scaling according to `scaling`
    :type unscaledParameter: float
    :param unscaledParameter:
    :type scaling: int
    :param scaling: parameter scaling
    :rtype: float
    :return: Scaled parameter
    """
    return _amici.getScaledParameter(unscaledParameter, scaling)

def scaleParameters(bufferUnscaled: 'gsl::span< amici::realtype const >', pscale: 'gsl::span< amici::ParameterScaling const >', bufferScaled: 'gsl::span< amici::realtype >'):
    """
    Apply parameter scaling according to `scaling`
    :type bufferUnscaled: gsl::span< amici::realtype const >
    :param bufferUnscaled:
    :type pscale: gsl::span< amici::ParameterScaling const >
    :param pscale: parameter scaling
    :type bufferScaled: gsl::span< amici::realtype >
    :param bufferScaled: destination
    """
    return _amici.scaleParameters(bufferUnscaled, pscale, bufferScaled)

class CpuTimer(object):
    """ Tracks elapsed CPU time using std::clock."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """Constructor"""
        _amici.CpuTimer_swiginit(self, _amici.new_CpuTimer())

    def reset(self):
        """Reset the timer"""
        return _amici.CpuTimer_reset(self)

    def elapsed_seconds(self) -> float:
        """
        Get elapsed CPU time in seconds since initialization or last reset
        :rtype: float
        :return: CPU time in seconds
        """
        return _amici.CpuTimer_elapsed_seconds(self)

    def elapsed_milliseconds(self) -> float:
        """
        Get elapsed CPU time in milliseconds since initialization or last
        reset
        :rtype: float
        :return: CPU time in milliseconds
        """
        return _amici.CpuTimer_elapsed_milliseconds(self)
    uses_thread_clock = _amici.CpuTimer_uses_thread_clock
    __swig_destroy__ = _amici.delete_CpuTimer
_amici.CpuTimer_swigregister(CpuTimer)

def _edata_repr(self: 'ExpData'):
    n_data_y = sum((self.isSetObservedData(it, iy) for it in range(self.nt()) for iy in range(self.nytrue())))
    n_sigma_y = sum((self.isSetObservedDataStdDev(it, iy) for it in range(self.nt()) for iy in range(self.nytrue())))
    n_data_z = sum((self.isSetObservedEvents(ie, iz) for ie in range(self.nmaxevent()) for iz in range(self.nztrue())))
    n_sigma_z = sum((self.isSetObservedEventsStdDev(ie, iz) for ie in range(self.nmaxevent()) for iz in range(self.nztrue())))
    custom_simulation_settings = []
    if self.pscale:
        custom_simulation_settings.append(f'parameter scales')
    if self.fixedParameters:
        custom_simulation_settings.append(f'constants')
    if self.fixedParametersPreequilibration:
        custom_simulation_settings.append(f'pre-equilibration condition')
    if self.t_presim:
        tmp = f'pre-simulation condition (t={self.t_presim})'
        if self.fixedParametersPresimulation:
            tmp += ' with custom constants'
        custom_simulation_settings.append(tmp)
    if self.reinitializeFixedParameterInitialStates and self.reinitialization_state_idxs_sim:
        custom_simulation_settings.append(f'{len(self.reinitialization_state_idxs_sim)} reinitialized states (simulation)')
    if self.reinitializeFixedParameterInitialStates and self.reinitialization_state_idxs_presim:
        custom_simulation_settings.append(f'{len(self.reinitialization_state_idxs_presim)} reinitialized states (presimulation)')
    if self.parameters:
        custom_simulation_settings.append(f'parameters')
    if self.x0:
        custom_simulation_settings.append(f'initial states')
    if self.sx0:
        custom_simulation_settings.append(f'initial state sensitivities')
    if custom_simulation_settings:
        custom_simulation_settings = ' with custom ' + ', '.join(custom_simulation_settings)
    else:
        custom_simulation_settings = ' without custom settings'
    return '\n'.join([self.this.__repr__()[:-1], f"  condition '{self.id}' starting at t={self.tstart_}" + custom_simulation_settings, f'  {self.nt()}x{self.nytrue()} time-resolved datapoints', f'    ({n_data_y}/{self.nt() * self.nytrue()} measurements & {n_sigma_y}/{self.nt() * self.nytrue()} sigmas set)', f'  {self.nmaxevent()}x{self.nztrue()} event-resolved datapoints', f'    ({n_data_z}/{self.nmaxevent() * self.nztrue()} measurements & {n_sigma_z}/{self.nmaxevent() * self.nztrue()} sigmas set)', '>'])

class ExpData(SimulationParameters):
    """
    ExpData carries all information about experimental or
    condition-specific data
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        default constructor

        |

        *Overload 2:*

        Copy constructor, needs to be declared to be generated in
        swig

        |

        *Overload 3:*

        constructor that only initializes dimensions

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track

        |

        *Overload 4:*

        constructor that initializes timepoints from vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)

        |

        *Overload 5:*

        constructor that initializes timepoints and fixed parameters from
        vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants (dimension: nk)

        |

        *Overload 6:*

        constructor that initializes timepoints and data from vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)
        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)
        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data
            (dimension: nt x nytrue, row-major)
        :type observedEvents: DoubleVector
        :param observedEvents: observed events
            (dimension: nmaxevents x nztrue, row-major)
        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed events/roots
            (dimension: nmaxevents x nztrue, row-major)

        |

        *Overload 7:*

        constructor that initializes with Model

        :type model: :py:class:`Model`
        :param model: pointer to model specification object

        |

        *Overload 8:*

        constructor that initializes with returnData, adds noise according
        to specified sigmas

        :type rdata: :py:class:`ReturnData`
        :param rdata: return data pointer with stored simulation results
        :type sigma_y: float
        :param sigma_y: scalar standard deviations for all observables
        :type sigma_z: float
        :param sigma_z: scalar standard deviations for all event observables

        |

        *Overload 9:*

        constructor that initializes with returnData, adds noise according
        to specified sigmas

        :type rdata: :py:class:`ReturnData`
        :param rdata: return data pointer with stored simulation results
        :type sigma_y: DoubleVector
        :param sigma_y: vector of standard deviations for observables
            (dimension: nytrue or nt x nytrue, row-major)
        :type sigma_z: DoubleVector
        :param sigma_z: vector of standard deviations for event observables
            (dimension: nztrue or nmaxevent x nztrue, row-major)
        """
        _amici.ExpData_swiginit(self, _amici.new_ExpData(*args))
    __swig_destroy__ = _amici.delete_ExpData

    def nytrue(self) -> int:
        """
        number of observables of the non-augmented model

        :rtype: int
        :return: number of observables of the non-augmented model
        """
        return _amici.ExpData_nytrue(self)

    def nztrue(self) -> int:
        """
        number of event observables of the non-augmented model

        :rtype: int
        :return: number of event observables of the non-augmented model
        """
        return _amici.ExpData_nztrue(self)

    def nmaxevent(self) -> int:
        """
        maximal number of events to track

        :rtype: int
        :return: maximal number of events to track
        """
        return _amici.ExpData_nmaxevent(self)

    def nt(self) -> int:
        """
        number of timepoints

        :rtype: int
        :return: number of timepoints
        """
        return _amici.ExpData_nt(self)

    def setTimepoints(self, ts: 'Sequence[float]'):
        """
        Set output timepoints.

        :type ts: DoubleVector
        :param ts: timepoints
        """
        return _amici.ExpData_setTimepoints(self, ts)

    def getTimepoints(self) -> Tuple[float]:
        """
        Get output timepoints.

        :rtype: DoubleVector
        :return: ExpData::ts
        """
        return _amici.ExpData_getTimepoints(self)

    def getTimepoint(self, it: int) -> float:
        """
        Get timepoint for the given index

        :type it: int
        :param it: timepoint index

        :rtype: float
        :return: timepoint timepoint at index
        """
        return _amici.ExpData_getTimepoint(self, it)

    def setObservedData(self, *args):
        """
        *Overload 1:*

        Set all measurements.

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)

        |

        *Overload 2:*

        Set measurements for a given observable index

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpData_setObservedData(self, *args)

    def isSetObservedData(self, it: int, iy: int) -> bool:
        """
        Whether there is a measurement for the given time- and observable-
        index.

        :type it: int
        :param it: time index
        :type iy: int
        :param iy: observable index

        :rtype: boolean
        :return: boolean specifying if data was set
        """
        return _amici.ExpData_isSetObservedData(self, it, iy)

    def getObservedData(self) -> Tuple[float]:
        """
        Get all measurements.

        :rtype: DoubleVector
        :return: observed data (dimension: nt x nytrue, row-major)
        """
        return _amici.ExpData_getObservedData(self)

    def getObservedDataPtr(self, it: int) -> 'amici::realtype const *':
        """
        Get measurements for a given timepoint index.

        :type it: int
        :param it: timepoint index

        :rtype: float
        :return: pointer to observed data at index (dimension: nytrue)
        """
        return _amici.ExpData_getObservedDataPtr(self, it)

    def setObservedDataStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviations for measurements.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt x nytrue, row-major)

        |

        *Overload 2:*

        Set indentical standard deviation for all measurements.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviations of observed data for a
        specific observable index.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt)
        :type iy: int
        :param iy: observed data index

        |

        *Overload 4:*

        Set all standard deviation for a given observable index to the
        input value.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpData_setObservedDataStdDev(self, *args)

    def isSetObservedDataStdDev(self, it: int, iy: int) -> bool:
        """
        Whether standard deviation for a measurement at
        specified timepoint- and observable index has been set.

        :type it: int
        :param it: time index
        :type iy: int
        :param iy: observable index
        :rtype: boolean
        :return: boolean specifying if standard deviation of data was set
        """
        return _amici.ExpData_isSetObservedDataStdDev(self, it, iy)

    def getObservedDataStdDev(self) -> Tuple[float]:
        """
        Get measurement standard deviations.

        :rtype: DoubleVector
        :return: standard deviation of observed data
        """
        return _amici.ExpData_getObservedDataStdDev(self)

    def getObservedDataStdDevPtr(self, it: int) -> 'amici::realtype const *':
        """
        Get pointer to measurement standard deviations.

        :type it: int
        :param it: timepoint index
        :rtype: float
        :return: pointer to standard deviation of observed data at index
        """
        return _amici.ExpData_getObservedDataStdDevPtr(self, it)

    def setObservedEvents(self, *args):
        """
        *Overload 1:*

        set function that copies observed event data from input to
        ExpData::observedEvents

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent x nztrue,
            row-major)

        |

        *Overload 2:*

        set function that copies observed event data for specific event
        observable

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent)
        :type iz: int
        :param iz: observed event data index
        """
        return _amici.ExpData_setObservedEvents(self, *args)

    def isSetObservedEvents(self, ie: int, iz: int) -> bool:
        """
        get function that checks whether event data at specified indices
        has been set

        :type ie: int
        :param ie: event index
        :type iz: int
        :param iz: event observable index
        :rtype: boolean
        :return: boolean specifying if data was set
        """
        return _amici.ExpData_isSetObservedEvents(self, ie, iz)

    def getObservedEvents(self) -> Tuple[float]:
        """
        get function that copies data from ExpData::mz to output

        :rtype: DoubleVector
        :return: observed event data
        """
        return _amici.ExpData_getObservedEvents(self)

    def getObservedEventsPtr(self, ie: int) -> 'amici::realtype const *':
        """
        get function that returns a pointer to observed data at ieth
        occurrence

        :type ie: int
        :param ie: event occurrence

        :rtype: float
        :return: pointer to observed event data at ieth occurrence
        """
        return _amici.ExpData_getObservedEventsPtr(self, ie)

    def setObservedEventsStdDev(self, *args):
        """
        *Overload 1:*

        set function that copies data from input to
        ExpData::observedEventsStdDev

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed event data

        |

        *Overload 2:*

        set function that sets all ExpData::observedDataStdDev to the
        input value

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        set function that copies standard deviation of observed data for
        specific observable

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed data
            (dimension: nmaxevent)
        :type iz: int
        :param iz: observed data index

        |

        *Overload 4:*

        set function that sets all standard deviation of a specific
        observable to the input value

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iz: int
        :param iz: observed data index
        """
        return _amici.ExpData_setObservedEventsStdDev(self, *args)

    def isSetObservedEventsStdDev(self, ie: int, iz: int) -> bool:
        """
        get function that checks whether standard deviation of even data
        at specified indices has been set

        :type ie: int
        :param ie: event index
        :type iz: int
        :param iz: event observable index
        :rtype: boolean
        :return: boolean specifying if standard deviation of event data was set
        """
        return _amici.ExpData_isSetObservedEventsStdDev(self, ie, iz)

    def getObservedEventsStdDev(self) -> Tuple[float]:
        """
        get function that copies data from ExpData::observedEventsStdDev
        to output

        :rtype: DoubleVector
        :return: standard deviation of observed event data
        """
        return _amici.ExpData_getObservedEventsStdDev(self)

    def getObservedEventsStdDevPtr(self, ie: int) -> 'amici::realtype const *':
        """
        get function that returns a pointer to standard deviation of
        observed event data at ie-th occurrence

        :type ie: int
        :param ie: event occurrence

        :rtype: float
        :return: pointer to standard deviation of observed event data at ie-th
            occurrence
        """
        return _amici.ExpData_getObservedEventsStdDevPtr(self, ie)
    id = property(_amici.ExpData_id_get, _amici.ExpData_id_set, doc='Arbitrary (not necessarily unique) identifier.')

    def __repr__(self):
        return _edata_repr(self)
_amici.ExpData_swigregister(ExpData)

def checkSigmaPositivity(*args):
    """
    *Overload 1:*

    checks input vector of sigmas for not strictly positive values

    :type sigmaVector: DoubleVector
    :param sigmaVector: vector input to be checked
    :type vectorName: string
    :param vectorName: name of the input

    |

    *Overload 2:*

    checks input scalar sigma for not strictly positive value

    :type sigma: float
    :param sigma: input to be checked
    :type sigmaName: string
    :param sigmaName: name of the input
    """
    return _amici.checkSigmaPositivity(*args)

def _solver_repr(self: 'Solver'):
    return '\n'.join([self.this.__repr__()[:-1], f'  reporting_mode: {RDataReporting(self.getReturnDataReportingMode())!r}', f'  sens_meth: {SensitivityMethod(self.getSensitivityMethod())!r}', f'  sens_order: {SensitivityOrder(self.getSensitivityOrder())!r}', f'  sens_meth_preeq: {SensitivityMethod(self.getSensitivityMethodPreequilibration())!r}', f'  maxsteps: {self.getMaxSteps()}', f'  maxtime: {self.getMaxTime()}s', f'  abs_tol: {self.getAbsoluteTolerance()}', f'  rel_tol: {self.getRelativeTolerance()}', f'  abs_tol_b: {self.getAbsoluteToleranceB()}', f'  rel_tol_b: {self.getRelativeToleranceB()}', f'  abs_tol_fsa: {self.getAbsoluteToleranceFSA()}', f'  rel_tol_fsa: {self.getRelativeToleranceFSA()}', f'  abs_tol_quad: {self.getAbsoluteToleranceQuadratures()}', f'  rel_tol_quad: {self.getRelativeToleranceQuadratures()}', f'  abs_tol_ss: {self.getAbsoluteToleranceSteadyState()}', f'  rel_tol_ss: {self.getRelativeToleranceSteadyState()}', f'  abs_tol_sss: {self.getAbsoluteToleranceSteadyStateSensi()}', f'  rel_tol_sss: {self.getRelativeToleranceSteadyStateSensi()}', f'  int_sens_meth: {InternalSensitivityMethod(self.getInternalSensitivityMethod())!r}', f'  int_type: {InterpolationType(self.getInterpolationType())!r}', f'  linsol: {LinearSolver(self.getLinearSolver())!r}', f'  lmm: {LinearMultistepMethod(self.getLinearMultistepMethod())!r}', f'  newton_damp_mode: {NewtonDampingFactorMode(self.getNewtonDampingFactorMode())!r}', f'  newton_damp_lb: {self.getNewtonDampingFactorLowerBound()}', f'  newton_maxsteps: {self.getNewtonMaxSteps()}', f'  newton_ss_check: {self.getNewtonStepSteadyStateCheck()}', f'  sens_ss_check: {self.getSensiSteadyStateCheck()}', f'  interpolation_type: {InterpolationType(self.getInterpolationType())!r}', f'  ism: {InternalSensitivityMethod(self.getInternalSensitivityMethod())!r}', f'  nlsol_iter: {NonlinearSolverIteration(self.getNonlinearSolverIteration())!r}', f'  stability_limit: {self.getStabilityLimitFlag()}', f'  state_ordering: {self.getStateOrdering()}', '>'])

class Solver(object):
    """
    The Solver class provides a generic interface to CVODES and IDAS solvers,
    individual realizations are realized in the CVodeSolver and the IDASolver
    class. All transient private/protected members (CVODES/IDAS memory, interface
    variables and status flags) are specified as mutable and not included in
    serialization or equality checks. No solver setting parameter should be
    marked mutable.

    NOTE: Any changes in data members here must be propagated to copy ctor,
    equality operator, serialization functions in serialization.h, and
    amici::hdf5::(read/write)SolverSettings(From/To)HDF5 in hdf5.cpp.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_Solver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :rtype: Solver
        :return: The clone
        """
        return _amici.Solver_clone(self)

    def getSensitivityMethod(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method
        :rtype: SensitivityMethod
        :return: method enum
        """
        return _amici.Solver_getSensitivityMethod(self)

    def setSensitivityMethod(self, sensi_meth: 'SensitivityMethod'):
        """
        Set sensitivity method
        :type sensi_meth: SensitivityMethod
        :param sensi_meth:
        """
        return _amici.Solver_setSensitivityMethod(self, sensi_meth)

    def getSensitivityMethodPreequilibration(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method during preequilibration
        :rtype: SensitivityMethod
        :return: method enum
        """
        return _amici.Solver_getSensitivityMethodPreequilibration(self)

    def setSensitivityMethodPreequilibration(self, sensi_meth_preeq: 'SensitivityMethod'):
        """
        Set sensitivity method for preequilibration
        :type sensi_meth_preeq: SensitivityMethod
        :param sensi_meth_preeq:
        """
        return _amici.Solver_setSensitivityMethodPreequilibration(self, sensi_meth_preeq)

    def getNewtonMaxSteps(self) -> int:
        """
        Get maximum number of allowed Newton steps for steady state
        computation
        :rtype: int
        :return: 
        """
        return _amici.Solver_getNewtonMaxSteps(self)

    def setNewtonMaxSteps(self, newton_maxsteps: int):
        """
        Set maximum number of allowed Newton steps for steady state
        computation
        :type newton_maxsteps: int
        :param newton_maxsteps:
        """
        return _amici.Solver_setNewtonMaxSteps(self, newton_maxsteps)

    def getNewtonDampingFactorMode(self) -> 'NewtonDampingFactorMode':
        """
        Get a state of the damping factor used in the Newton solver
        :rtype: NewtonDampingFactorMode
        :return: 
        """
        return _amici.Solver_getNewtonDampingFactorMode(self)

    def setNewtonDampingFactorMode(self, dampingFactorMode: 'NewtonDampingFactorMode'):
        """
        Turn on/off a damping factor in the Newton method
        :type dampingFactorMode: NewtonDampingFactorMode
        :param dampingFactorMode:
        """
        return _amici.Solver_setNewtonDampingFactorMode(self, dampingFactorMode)

    def getNewtonDampingFactorLowerBound(self) -> float:
        """
        Get a lower bound of the damping factor used in the Newton solver
        :rtype: float
        :return: 
        """
        return _amici.Solver_getNewtonDampingFactorLowerBound(self)

    def setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound: float):
        """
        Set a lower bound of the damping factor in the Newton solver
        :type dampingFactorLowerBound: float
        :param dampingFactorLowerBound:
        """
        return _amici.Solver_setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound)

    def getSensitivityOrder(self) -> 'SensitivityOrder':
        """
        Get sensitivity order
        :rtype: SensitivityOrder
        :return: sensitivity order
        """
        return _amici.Solver_getSensitivityOrder(self)

    def setSensitivityOrder(self, sensi: 'SensitivityOrder'):
        """
        Set the sensitivity order
        :type sensi: SensitivityOrder
        :param sensi: sensitivity order
        """
        return _amici.Solver_setSensitivityOrder(self, sensi)

    def getRelativeTolerance(self) -> float:
        """
        Get the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :rtype: float
        :return: relative tolerances
        """
        return _amici.Solver_getRelativeTolerance(self)

    def setRelativeTolerance(self, rtol: float):
        """
        Sets the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeTolerance(self, rtol)

    def getAbsoluteTolerance(self) -> float:
        """
        Get the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :rtype: float
        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteTolerance(self)

    def setAbsoluteTolerance(self, atol: float):
        """
        Sets the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteTolerance(self, atol)

    def getRelativeToleranceFSA(self) -> float:
        """
        Returns the relative tolerances for the forward sensitivity
        problem
        :rtype: float
        :return: relative tolerances
        """
        return _amici.Solver_getRelativeToleranceFSA(self)

    def setRelativeToleranceFSA(self, rtol: float):
        """
        Sets the relative tolerances for the forward sensitivity problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceFSA(self, rtol)

    def getAbsoluteToleranceFSA(self) -> float:
        """
        Returns the absolute tolerances for the forward sensitivity
        problem
        :rtype: float
        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteToleranceFSA(self)

    def setAbsoluteToleranceFSA(self, atol: float):
        """
        Sets the absolute tolerances for the forward sensitivity problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceFSA(self, atol)

    def getRelativeToleranceB(self) -> float:
        """
        Returns the relative tolerances for the adjoint sensitivity
        problem
        :rtype: float
        :return: relative tolerances
        """
        return _amici.Solver_getRelativeToleranceB(self)

    def setRelativeToleranceB(self, rtol: float):
        """
        Sets the relative tolerances for the adjoint sensitivity problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceB(self, rtol)

    def getAbsoluteToleranceB(self) -> float:
        """
        Returns the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :rtype: float
        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteToleranceB(self)

    def setAbsoluteToleranceB(self, atol: float):
        """
        Sets the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceB(self, atol)

    def getRelativeToleranceQuadratures(self) -> float:
        """
        Returns the relative tolerance for the quadrature problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceQuadratures(self)

    def setRelativeToleranceQuadratures(self, rtol: float):
        """
        sets the relative tolerance for the quadrature problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceQuadratures(self, rtol)

    def getAbsoluteToleranceQuadratures(self) -> float:
        """
        returns the absolute tolerance for the quadrature problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceQuadratures(self)

    def setAbsoluteToleranceQuadratures(self, atol: float):
        """
        sets the absolute tolerance for the quadrature problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceQuadratures(self, atol)

    def getSteadyStateToleranceFactor(self) -> float:
        """
        returns the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :rtype: float
        :return: steady state simulation tolerance factor
        """
        return _amici.Solver_getSteadyStateToleranceFactor(self)

    def setSteadyStateToleranceFactor(self, factor: float):
        """
        set the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :type factor: float
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.Solver_setSteadyStateToleranceFactor(self, factor)

    def getRelativeToleranceSteadyState(self) -> float:
        """
        returns the relative tolerance for the steady state problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceSteadyState(self)

    def setRelativeToleranceSteadyState(self, rtol: float):
        """
        sets the relative tolerance for the steady state problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceSteadyState(self, rtol)

    def getAbsoluteToleranceSteadyState(self) -> float:
        """
        returns the absolute tolerance for the steady state problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceSteadyState(self)

    def setAbsoluteToleranceSteadyState(self, atol: float):
        """
        sets the absolute tolerance for the steady state problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceSteadyState(self, atol)

    def getSteadyStateSensiToleranceFactor(self) -> float:
        """
        returns the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :rtype: float
        :return: steady state simulation tolerance factor
        """
        return _amici.Solver_getSteadyStateSensiToleranceFactor(self)

    def setSteadyStateSensiToleranceFactor(self, factor: float):
        """
        set the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :type factor: float
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.Solver_setSteadyStateSensiToleranceFactor(self, factor)

    def getRelativeToleranceSteadyStateSensi(self) -> float:
        """
        returns the relative tolerance for the sensitivities of the
        steady state problem
        :rtype: float
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceSteadyStateSensi(self)

    def setRelativeToleranceSteadyStateSensi(self, rtol: float):
        """
        sets the relative tolerance for the sensitivities of the
        steady state problem
        :type rtol: float
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceSteadyStateSensi(self, rtol)

    def getAbsoluteToleranceSteadyStateSensi(self) -> float:
        """
        returns the absolute tolerance for the sensitivities of the
        steady state problem
        :rtype: float
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceSteadyStateSensi(self)

    def setAbsoluteToleranceSteadyStateSensi(self, atol: float):
        """
        sets the absolute tolerance for the sensitivities of the
        steady state problem
        :type atol: float
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceSteadyStateSensi(self, atol)

    def getMaxSteps(self) -> int:
        """
        returns the maximum number of solver steps for the forward
        problem
        :rtype: int
        :return: maximum number of solver steps
        """
        return _amici.Solver_getMaxSteps(self)

    def setMaxSteps(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the forward problem
        :type maxsteps: int
        :param maxsteps: maximum number of solver steps (positive number)
        """
        return _amici.Solver_setMaxSteps(self, maxsteps)

    def getMaxTime(self) -> float:
        """
        Returns the maximum time allowed for integration
        :rtype: float
        :return: Time in seconds
        """
        return _amici.Solver_getMaxTime(self)

    def setMaxTime(self, maxtime: float):
        """
        Set the maximum CPU time allowed for integration
        :type maxtime: float
        :param maxtime: Time in seconds. Zero means infinite time.
        """
        return _amici.Solver_setMaxTime(self, maxtime)

    def getMaxStepsBackwardProblem(self) -> int:
        """
        returns the maximum number of solver steps for the backward
        problem
        :rtype: int
        :return: maximum number of solver steps
        """
        return _amici.Solver_getMaxStepsBackwardProblem(self)

    def setMaxStepsBackwardProblem(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the backward problem

        :type maxsteps: int
        :param maxsteps: maximum number of solver steps (non-negative number)

        Notes: default behaviour (100 times the value for the forward problem) can
        be restored by passing maxsteps=0
        """
        return _amici.Solver_setMaxStepsBackwardProblem(self, maxsteps)

    def getLinearMultistepMethod(self) -> 'LinearMultistepMethod':
        """
        returns the linear system multistep method
        :rtype: LinearMultistepMethod
        :return: linear system multistep method
        """
        return _amici.Solver_getLinearMultistepMethod(self)

    def setLinearMultistepMethod(self, lmm: 'LinearMultistepMethod'):
        """
        sets the linear system multistep method
        :type lmm: LinearMultistepMethod
        :param lmm: linear system multistep method
        """
        return _amici.Solver_setLinearMultistepMethod(self, lmm)

    def getNonlinearSolverIteration(self) -> 'NonlinearSolverIteration':
        """
        returns the nonlinear system solution method
        :rtype: NonlinearSolverIteration
        :return: 
        """
        return _amici.Solver_getNonlinearSolverIteration(self)

    def setNonlinearSolverIteration(self, iter: 'NonlinearSolverIteration'):
        """
        sets the nonlinear system solution method
        :type iter: NonlinearSolverIteration
        :param iter: nonlinear system solution method
        """
        return _amici.Solver_setNonlinearSolverIteration(self, iter)

    def getInterpolationType(self) -> 'InterpolationType':
        """
        getInterpolationType
        :rtype: InterpolationType
        :return: 
        """
        return _amici.Solver_getInterpolationType(self)

    def setInterpolationType(self, interpType: 'InterpolationType'):
        """
        sets the interpolation of the forward solution that is used for
        the backwards problem
        :type interpType: InterpolationType
        :param interpType: interpolation type
        """
        return _amici.Solver_setInterpolationType(self, interpType)

    def getStateOrdering(self) -> int:
        """
        Gets KLU / SuperLUMT state ordering mode

        :rtype: int
        :return: State-ordering as integer according to
            SUNLinSolKLU::StateOrdering or SUNLinSolSuperLUMT::StateOrdering (which
            differ).
        """
        return _amici.Solver_getStateOrdering(self)

    def setStateOrdering(self, ordering: int):
        """
        Sets KLU / SuperLUMT state ordering mode

        This only applies when linsol is set to LinearSolver::KLU or
        LinearSolver::SuperLUMT. Mind the difference between
        SUNLinSolKLU::StateOrdering and SUNLinSolSuperLUMT::StateOrdering.
        :type ordering: int
        :param ordering: state ordering
        """
        return _amici.Solver_setStateOrdering(self, ordering)

    def getStabilityLimitFlag(self) -> bool:
        """
        returns stability limit detection mode
        :rtype: boolean
        :return: stldet can be false (deactivated) or true (activated)
        """
        return _amici.Solver_getStabilityLimitFlag(self)

    def setStabilityLimitFlag(self, stldet: bool):
        """
        set stability limit detection mode
        :type stldet: boolean
        :param stldet: can be false (deactivated) or true (activated)
        """
        return _amici.Solver_setStabilityLimitFlag(self, stldet)

    def getLinearSolver(self) -> 'LinearSolver':
        """
        getLinearSolver
        :rtype: LinearSolver
        :return: 
        """
        return _amici.Solver_getLinearSolver(self)

    def setLinearSolver(self, linsol: 'LinearSolver'):
        """
        setLinearSolver
        :type linsol: LinearSolver
        :param linsol:
        """
        return _amici.Solver_setLinearSolver(self, linsol)

    def getInternalSensitivityMethod(self) -> 'InternalSensitivityMethod':
        """
        returns the internal sensitivity method
        :rtype: InternalSensitivityMethod
        :return: internal sensitivity method
        """
        return _amici.Solver_getInternalSensitivityMethod(self)

    def setInternalSensitivityMethod(self, ism: 'InternalSensitivityMethod'):
        """
        sets the internal sensitivity method
        :type ism: InternalSensitivityMethod
        :param ism: internal sensitivity method
        """
        return _amici.Solver_setInternalSensitivityMethod(self, ism)

    def getReturnDataReportingMode(self) -> 'RDataReporting':
        """
        returns the ReturnData reporting mode
        :rtype: RDataReporting
        :return: ReturnData reporting mode
        """
        return _amici.Solver_getReturnDataReportingMode(self)

    def setReturnDataReportingMode(self, rdrm: 'RDataReporting'):
        """
        sets the ReturnData reporting mode
        :type rdrm: RDataReporting
        :param rdrm: ReturnData reporting mode
        """
        return _amici.Solver_setReturnDataReportingMode(self, rdrm)

    def nx(self) -> int:
        """
        number of states with which the solver was initialized
        :rtype: int
        :return: x.getLength()
        """
        return _amici.Solver_nx(self)

    def nplist(self) -> int:
        """
        number of parameters with which the solver was initialized
        :rtype: int
        :return: sx.getLength()
        """
        return _amici.Solver_nplist(self)

    def nquad(self) -> int:
        """
        number of quadratures with which the solver was initialized
        :rtype: int
        :return: xQB.getLength()
        """
        return _amici.Solver_nquad(self)

    def computingFSA(self) -> bool:
        """
        check if FSA is being computed
        :rtype: boolean
        :return: flag
        """
        return _amici.Solver_computingFSA(self)

    def computingASA(self) -> bool:
        """
        check if ASA is being computed
        :rtype: boolean
        :return: flag
        """
        return _amici.Solver_computingASA(self)

    def getNewtonStepSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed. If activated, convergence checks are limited to every 25 steps
        in the simulation solver to limit performance impact.
        :rtype: boolean
        :return: boolean flag indicating newton step (true) or the right hand side
            (false)
        """
        return _amici.Solver_getNewtonStepSteadyStateCheck(self)

    def getSensiSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed.
        :rtype: boolean
        :return: boolean flag indicating state and sensitivity equations (true) or
            only state variables (false).
        """
        return _amici.Solver_getSensiSteadyStateCheck(self)

    def setNewtonStepSteadyStateCheck(self, flag: bool):
        """
        Sets how convergence checks for steadystate computation are
        performed.
        :type flag: boolean
        :param flag: boolean flag to pick newton step (true) or the right hand
            side (false, default)
        """
        return _amici.Solver_setNewtonStepSteadyStateCheck(self, flag)

    def setSensiSteadyStateCheck(self, flag: bool):
        """
        Sets for which variables convergence checks for steadystate
        computation are performed.
        :type flag: boolean
        :param flag: boolean flag to pick state and sensitivity equations (true,
            default) or only state variables (false).
        """
        return _amici.Solver_setSensiSteadyStateCheck(self, flag)
    logger = property(_amici.Solver_logger_get, _amici.Solver_logger_set, doc=' logger')
_amici.Solver_swigregister(Solver)

def wrapErrHandlerFn(error_code: int, module: 'char const *', function: 'char const *', msg: 'char *', eh_data: 'void *'):
    """
    Extracts diagnosis information from solver memory block and
    passes them to the specified output function

    :type error_code: int
    :param error_code: error identifier
    :type module: string
    :param module: name of the module in which the error occurred
    :type function: string
    :param function: name of the function in which the error occurred
    :type msg: string
    :param msg: error message
    :type eh_data: None
    :param eh_data: amici::Solver as void*
    """
    return _amici.wrapErrHandlerFn(error_code, module, function, msg, eh_data)

class IDASolver(Solver):
    """The IDASolver class is a wrapper around the SUNDIALS IDAS solver."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_IDASolver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :rtype: Solver
        :return: The clone
        """
        return _amici.IDASolver_clone(self)

    def reInitPostProcessF(self, tnext: float):
        return _amici.IDASolver_reInitPostProcessF(self, tnext)

    def reInitPostProcessB(self, tnext: float):
        return _amici.IDASolver_reInitPostProcessB(self, tnext)

    def quadSStolerancesB(self, which: int, reltolQB: float, abstolQB: float):
        return _amici.IDASolver_quadSStolerancesB(self, which, reltolQB, abstolQB)

    def quadSStolerances(self, reltolQ: float, abstolQ: float):
        return _amici.IDASolver_quadSStolerances(self, reltolQ, abstolQ)

    def solve(self, tout: float, itask: int) -> int:
        return _amici.IDASolver_solve(self, tout, itask)

    def solveF(self, tout: float, itask: int, ncheckPtr: 'int *') -> int:
        return _amici.IDASolver_solveF(self, tout, itask, ncheckPtr)

    def getDky(self, t: float, k: int):
        return _amici.IDASolver_getDky(self, t, k)

    def getSens(self):
        return _amici.IDASolver_getSens(self)

    def getSensDky(self, t: float, k: int):
        return _amici.IDASolver_getSensDky(self, t, k)

    def getB(self, which: int):
        return _amici.IDASolver_getB(self, which)

    def getDkyB(self, t: float, k: int, which: int):
        return _amici.IDASolver_getDkyB(self, t, k, which)

    def getQuadB(self, which: int):
        return _amici.IDASolver_getQuadB(self, which)

    def getQuadDkyB(self, t: float, k: int, which: int):
        return _amici.IDASolver_getQuadDkyB(self, t, k, which)

    def getQuad(self, t: 'amici::realtype &'):
        return _amici.IDASolver_getQuad(self, t)

    def getQuadDky(self, t: float, k: int):
        return _amici.IDASolver_getQuadDky(self, t, k)

    def setStopTime(self, tstop: float):
        return _amici.IDASolver_setStopTime(self, tstop)

    def getModel(self) -> 'Model':
        return _amici.IDASolver_getModel(self)

    def setLinearSolver(self):
        return _amici.IDASolver_setLinearSolver(self)

    def setLinearSolverB(self, which: int):
        return _amici.IDASolver_setLinearSolverB(self, which)

    def setNonLinearSolver(self):
        return _amici.IDASolver_setNonLinearSolver(self)

    def setNonLinearSolverSens(self):
        return _amici.IDASolver_setNonLinearSolverSens(self)

    def setNonLinearSolverB(self, which: int):
        return _amici.IDASolver_setNonLinearSolverB(self, which)

    def __repr__(self):
        return _solver_repr(self)

    def __init__(self):
        _amici.IDASolver_swiginit(self, _amici.new_IDASolver())
_amici.IDASolver_swigregister(IDASolver)

class CVodeSolver(Solver):
    """The CVodeSolver class is a wrapper around the SUNDIALS CVODES solver."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_CVodeSolver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :rtype: Solver
        :return: The clone
        """
        return _amici.CVodeSolver_clone(self)

    def solve(self, tout: float, itask: int) -> int:
        return _amici.CVodeSolver_solve(self, tout, itask)

    def solveF(self, tout: float, itask: int, ncheckPtr: 'int *') -> int:
        return _amici.CVodeSolver_solveF(self, tout, itask, ncheckPtr)

    def getDky(self, t: float, k: int):
        return _amici.CVodeSolver_getDky(self, t, k)

    def getSensDky(self, t: float, k: int):
        return _amici.CVodeSolver_getSensDky(self, t, k)

    def getQuadDkyB(self, t: float, k: int, which: int):
        return _amici.CVodeSolver_getQuadDkyB(self, t, k, which)

    def getDkyB(self, t: float, k: int, which: int):
        return _amici.CVodeSolver_getDkyB(self, t, k, which)

    def setStopTime(self, tstop: float):
        return _amici.CVodeSolver_setStopTime(self, tstop)

    def getModel(self) -> 'Model':
        return _amici.CVodeSolver_getModel(self)

    def setLinearSolver(self, *args):
        return _amici.CVodeSolver_setLinearSolver(self, *args)

    def setLinearSolverB(self, which: int):
        return _amici.CVodeSolver_setLinearSolverB(self, which)

    def setNonLinearSolver(self):
        return _amici.CVodeSolver_setNonLinearSolver(self)

    def setNonLinearSolverSens(self):
        return _amici.CVodeSolver_setNonLinearSolverSens(self)

    def setNonLinearSolverB(self, which: int):
        return _amici.CVodeSolver_setNonLinearSolverB(self, which)

    def __repr__(self):
        return _solver_repr(self)

    def __init__(self):
        _amici.CVodeSolver_swiginit(self, _amici.new_CVodeSolver())
_amici.CVodeSolver_swigregister(CVodeSolver)
ModelQuantity_J = _amici.ModelQuantity_J
ModelQuantity_JB = _amici.ModelQuantity_JB
ModelQuantity_Jv = _amici.ModelQuantity_Jv
ModelQuantity_JvB = _amici.ModelQuantity_JvB
ModelQuantity_JDiag = _amici.ModelQuantity_JDiag
ModelQuantity_sx = _amici.ModelQuantity_sx
ModelQuantity_sy = _amici.ModelQuantity_sy
ModelQuantity_sz = _amici.ModelQuantity_sz
ModelQuantity_srz = _amici.ModelQuantity_srz
ModelQuantity_ssigmay = _amici.ModelQuantity_ssigmay
ModelQuantity_ssigmaz = _amici.ModelQuantity_ssigmaz
ModelQuantity_xdot = _amici.ModelQuantity_xdot
ModelQuantity_sxdot = _amici.ModelQuantity_sxdot
ModelQuantity_xBdot = _amici.ModelQuantity_xBdot
ModelQuantity_x0_rdata = _amici.ModelQuantity_x0_rdata
ModelQuantity_x0 = _amici.ModelQuantity_x0
ModelQuantity_x_rdata = _amici.ModelQuantity_x_rdata
ModelQuantity_x = _amici.ModelQuantity_x
ModelQuantity_dwdw = _amici.ModelQuantity_dwdw
ModelQuantity_dwdx = _amici.ModelQuantity_dwdx
ModelQuantity_dwdp = _amici.ModelQuantity_dwdp
ModelQuantity_y = _amici.ModelQuantity_y
ModelQuantity_dydp = _amici.ModelQuantity_dydp
ModelQuantity_dydx = _amici.ModelQuantity_dydx
ModelQuantity_w = _amici.ModelQuantity_w
ModelQuantity_root = _amici.ModelQuantity_root
ModelQuantity_qBdot = _amici.ModelQuantity_qBdot
ModelQuantity_qBdot_ss = _amici.ModelQuantity_qBdot_ss
ModelQuantity_xBdot_ss = _amici.ModelQuantity_xBdot_ss
ModelQuantity_JSparseB_ss = _amici.ModelQuantity_JSparseB_ss
ModelQuantity_deltax = _amici.ModelQuantity_deltax
ModelQuantity_deltasx = _amici.ModelQuantity_deltasx
ModelQuantity_deltaxB = _amici.ModelQuantity_deltaxB
ModelQuantity_k = _amici.ModelQuantity_k
ModelQuantity_p = _amici.ModelQuantity_p
ModelQuantity_ts = _amici.ModelQuantity_ts
ModelQuantity_dJydy = _amici.ModelQuantity_dJydy
ModelQuantity_dJydy_matlab = _amici.ModelQuantity_dJydy_matlab
ModelQuantity_deltaqB = _amici.ModelQuantity_deltaqB
ModelQuantity_dsigmaydp = _amici.ModelQuantity_dsigmaydp
ModelQuantity_dsigmaydy = _amici.ModelQuantity_dsigmaydy
ModelQuantity_dsigmazdp = _amici.ModelQuantity_dsigmazdp
ModelQuantity_dJydsigma = _amici.ModelQuantity_dJydsigma
ModelQuantity_dJydx = _amici.ModelQuantity_dJydx
ModelQuantity_dzdx = _amici.ModelQuantity_dzdx
ModelQuantity_dzdp = _amici.ModelQuantity_dzdp
ModelQuantity_dJrzdsigma = _amici.ModelQuantity_dJrzdsigma
ModelQuantity_dJrzdz = _amici.ModelQuantity_dJrzdz
ModelQuantity_dJrzdx = _amici.ModelQuantity_dJrzdx
ModelQuantity_dJzdsigma = _amici.ModelQuantity_dJzdsigma
ModelQuantity_dJzdz = _amici.ModelQuantity_dJzdz
ModelQuantity_dJzdx = _amici.ModelQuantity_dJzdx
ModelQuantity_drzdp = _amici.ModelQuantity_drzdp
ModelQuantity_drzdx = _amici.ModelQuantity_drzdx

class Model(AbstractModel, ModelDimensions):
    """
    The Model class represents an AMICI ODE/DAE model.

    The model can compute various model related quantities based on symbolically
    generated code.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_Model

    def clone(self) -> 'Model':
        """
        Clone this instance.
        :rtype: Model
        :return: The clone
        """
        return _amici.Model_clone(self)

    def initializeSplines(self):
        """Initialization of spline functions"""
        return _amici.Model_initializeSplines(self)

    def initializeSplineSensitivities(self):
        """Initialization of spline sensitivity functions"""
        return _amici.Model_initializeSplineSensitivities(self)

    def nplist(self) -> int:
        """
        Get number of parameters wrt to which sensitivities are computed.
        :rtype: int
        :return: Length of sensitivity index vector
        """
        return _amici.Model_nplist(self)

    def np(self) -> int:
        """
        Get total number of model parameters.
        :rtype: int
        :return: Length of parameter vector
        """
        return _amici.Model_np(self)

    def nk(self) -> int:
        """
        Get number of constants
        :rtype: int
        :return: Length of constant vector
        """
        return _amici.Model_nk(self)

    def ncl(self) -> int:
        """
        Get number of conservation laws.
        :rtype: int
        :return: Number of conservation laws (i.e., difference between `nx_rdata`
            and `nx_solver`).
        """
        return _amici.Model_ncl(self)

    def nx_reinit(self) -> int:
        """
        Get number of solver states subject to reinitialization.
        :rtype: int
        :return: Model member `nx_solver_reinit`
        """
        return _amici.Model_nx_reinit(self)

    def k(self) -> 'double const *':
        """
        Get fixed parameters.
        :rtype: float
        :return: Pointer to constants array
        """
        return _amici.Model_k(self)

    def nMaxEvent(self) -> int:
        """
        Get maximum number of events that may occur for each type.
        :rtype: int
        :return: Maximum number of events that may occur for each type
        """
        return _amici.Model_nMaxEvent(self)

    def setNMaxEvent(self, nmaxevent: int):
        """
        Set maximum number of events that may occur for each type.
        :type nmaxevent: int
        :param nmaxevent: Maximum number of events that may occur for each type
        """
        return _amici.Model_setNMaxEvent(self, nmaxevent)

    def nt(self) -> int:
        """
        Get number of timepoints.
        :rtype: int
        :return: Number of timepoints
        """
        return _amici.Model_nt(self)

    def getParameterScale(self) -> 'ParameterScalingVector':
        """
        Get parameter scale for each parameter.
        :rtype: ParameterScalingVector
        :return: Vector of parameter scales
        """
        return _amici.Model_getParameterScale(self)

    def getUnscaledParameters(self) -> Tuple[float]:
        """
        Get parameters with transformation according to parameter scale
        applied.
        :rtype: DoubleVector
        :return: Unscaled parameters
        """
        return _amici.Model_getUnscaledParameters(self)

    def getParameters(self) -> Tuple[float]:
        """
        Get parameter vector.
        :rtype: DoubleVector
        :return: The user-set parameters (see also `Model::getUnscaledParameters`)
        """
        return _amici.Model_getParameters(self)

    def getParameterById(self, par_id: str) -> float:
        """
        Get value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :rtype: float
        :return: Parameter value
        """
        return _amici.Model_getParameterById(self, par_id)

    def getParameterByName(self, par_name: str) -> float:
        """
        Get value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :rtype: float
        :return: Parameter value
        """
        return _amici.Model_getParameterByName(self, par_name)

    def setParameters(self, p: 'Sequence[float]'):
        """
        Set the parameter vector.
        :type p: DoubleVector
        :param p: Vector of parameters
        """
        return _amici.Model_setParameters(self, p)

    def setParameterById(self, *args):
        """
        *Overload 1:*

        Set model parameters according to the parameter IDs and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters IDs and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter IDs in p which are
            not model parameters

        |

        *Overload 2:*

        Set value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :type value: float
        :param value: Parameter value
        """
        return _amici.Model_setParameterById(self, *args)

    def setParametersByIdRegex(self, par_id_regex: str, value: float) -> int:
        """
        Set all values of model parameters with IDs matching the specified
        regular expression.
        :type par_id_regex: str
        :param par_id_regex: Parameter ID regex
        :type value: float
        :param value: Parameter value
        :rtype: int
        :return: Number of parameter IDs that matched the regex
        """
        return _amici.Model_setParametersByIdRegex(self, par_id_regex, value)

    def setParameterByName(self, *args):
        """
        *Overload 1:*

        Set value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :type value: float
        :param value: Parameter value

        |

        *Overload 2:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters

        |

        *Overload 3:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters
        """
        return _amici.Model_setParameterByName(self, *args)

    def setParametersByNameRegex(self, par_name_regex: str, value: float) -> int:
        """
        Set all values of all model parameters with names matching the
        specified regex.
        :type par_name_regex: str
        :param par_name_regex: Parameter name regex
        :type value: float
        :param value: Parameter value
        :rtype: int
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.Model_setParametersByNameRegex(self, par_name_regex, value)

    def getFixedParameters(self) -> Tuple[float]:
        """
        Get values of fixed parameters.
        :rtype: DoubleVector
        :return: Vector of fixed parameters with same ordering as in
            Model::getFixedParameterIds
        """
        return _amici.Model_getFixedParameters(self)

    def getFixedParameterById(self, par_id: str) -> float:
        """
        Get value of fixed parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :rtype: float
        :return: Parameter value
        """
        return _amici.Model_getFixedParameterById(self, par_id)

    def getFixedParameterByName(self, par_name: str) -> float:
        """
        Get value of fixed parameter with the specified name.

        If multiple parameters have the same name, the first parameter with
        matching name is returned.

        :type par_name: str
        :param par_name: Parameter name
        :rtype: float
        :return: Parameter value
        """
        return _amici.Model_getFixedParameterByName(self, par_name)

    def setFixedParameters(self, k: 'Sequence[float]'):
        """
        Set values for constants.
        :type k: DoubleVector
        :param k: Vector of fixed parameters
        """
        return _amici.Model_setFixedParameters(self, k)

    def setFixedParameterById(self, par_id: str, value: float):
        """
        Set value of first fixed parameter with the specified ID.
        :type par_id: str
        :param par_id: Fixed parameter id
        :type value: float
        :param value: Fixed parameter value
        """
        return _amici.Model_setFixedParameterById(self, par_id, value)

    def setFixedParametersByIdRegex(self, par_id_regex: str, value: float) -> int:
        """
        Set values of all fixed parameters with the ID matching the
        specified regex.
        :type par_id_regex: str
        :param par_id_regex: Fixed parameter name regex
        :type value: float
        :param value: Fixed parameter value
        :rtype: int
        :return: Number of fixed parameter IDs that matched the regex
        """
        return _amici.Model_setFixedParametersByIdRegex(self, par_id_regex, value)

    def setFixedParameterByName(self, par_name: str, value: float):
        """
        Set value of first fixed parameter with the specified name.
        :type par_name: str
        :param par_name: Fixed parameter ID
        :type value: float
        :param value: Fixed parameter value
        """
        return _amici.Model_setFixedParameterByName(self, par_name, value)

    def setFixedParametersByNameRegex(self, par_name_regex: str, value: float) -> int:
        """
        Set value of all fixed parameters with name matching the specified
        regex.
        :type par_name_regex: str
        :param par_name_regex: Fixed parameter name regex
        :type value: float
        :param value: Fixed parameter value
        :rtype: int
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.Model_setFixedParametersByNameRegex(self, par_name_regex, value)

    def getName(self) -> str:
        """
        Get the model name.
        :rtype: str
        :return: Model name
        """
        return _amici.Model_getName(self)

    def hasParameterNames(self) -> bool:
        """
        Report whether the model has parameter names set.

        :rtype: boolean
        :return: Boolean indicating whether parameter names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasParameterNames(self)

    def getParameterNames(self) -> Tuple[str]:
        """
        Get names of the model parameters.
        :rtype: StringVector
        :return: The parameter names
        """
        return _amici.Model_getParameterNames(self)

    def hasStateNames(self) -> bool:
        """
        Report whether the model has state names set.

        :rtype: boolean
        :return: Boolean indicating whether state names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasStateNames(self)

    def getStateNames(self) -> Tuple[str]:
        """
        Get names of the model states.
        :rtype: StringVector
        :return: State names
        """
        return _amici.Model_getStateNames(self)

    def getStateNamesSolver(self) -> Tuple[str]:
        """
        Get names of the solver states.
        :rtype: StringVector
        :return: State names
        """
        return _amici.Model_getStateNamesSolver(self)

    def hasFixedParameterNames(self) -> bool:
        """
        Report whether the model has fixed parameter names set.
        :rtype: boolean
        :return: Boolean indicating whether fixed parameter names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasFixedParameterNames(self)

    def getFixedParameterNames(self) -> Tuple[str]:
        """
        Get names of the fixed model parameters.
        :rtype: StringVector
        :return: Fixed parameter names
        """
        return _amici.Model_getFixedParameterNames(self)

    def hasObservableNames(self) -> bool:
        """
        Report whether the model has observable names set.
        :rtype: boolean
        :return: Boolean indicating whether observable names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasObservableNames(self)

    def getObservableNames(self) -> Tuple[str]:
        """
        Get names of the observables.
        :rtype: StringVector
        :return: Observable names
        """
        return _amici.Model_getObservableNames(self)

    def hasExpressionNames(self) -> bool:
        """
        Report whether the model has expression names set.
        :rtype: boolean
        :return: Boolean indicating whether expression names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasExpressionNames(self)

    def getExpressionNames(self) -> Tuple[str]:
        """
        Get names of the expressions.
        :rtype: StringVector
        :return: Expression names
        """
        return _amici.Model_getExpressionNames(self)

    def hasParameterIds(self) -> bool:
        """
        Report whether the model has parameter IDs set.
        :rtype: boolean
        :return: Boolean indicating whether parameter IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasParameterIds(self)

    def getParameterIds(self) -> Tuple[str]:
        """
        Get IDs of the model parameters.
        :rtype: StringVector
        :return: Parameter IDs
        """
        return _amici.Model_getParameterIds(self)

    def hasStateIds(self) -> bool:
        """
        Report whether the model has state IDs set.
        :rtype: boolean
        :return: Boolean indicating whether state IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasStateIds(self)

    def getStateIds(self) -> Tuple[str]:
        """
        Get IDs of the model states.
        :rtype: StringVector
        :return: State IDs
        """
        return _amici.Model_getStateIds(self)

    def getStateIdsSolver(self) -> Tuple[str]:
        """
        Get IDs of the solver states.
        :rtype: StringVector
        :return: State IDs
        """
        return _amici.Model_getStateIdsSolver(self)

    def hasFixedParameterIds(self) -> bool:
        """
        Report whether the model has fixed parameter IDs set.
        :rtype: boolean
        :return: Boolean indicating whether fixed parameter IDs were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasFixedParameterIds(self)

    def getFixedParameterIds(self) -> Tuple[str]:
        """
        Get IDs of the fixed model parameters.
        :rtype: StringVector
        :return: Fixed parameter IDs
        """
        return _amici.Model_getFixedParameterIds(self)

    def hasObservableIds(self) -> bool:
        """
        Report whether the model has observable IDs set.
        :rtype: boolean
        :return: Boolean indicating whether observable ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasObservableIds(self)

    def getObservableIds(self) -> Tuple[str]:
        """
        Get IDs of the observables.
        :rtype: StringVector
        :return: Observable IDs
        """
        return _amici.Model_getObservableIds(self)

    def hasExpressionIds(self) -> bool:
        """
        Report whether the model has expression IDs set.
        :rtype: boolean
        :return: Boolean indicating whether expression ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasExpressionIds(self)

    def getExpressionIds(self) -> Tuple[str]:
        """
        Get IDs of the expression.
        :rtype: StringVector
        :return: Expression IDs
        """
        return _amici.Model_getExpressionIds(self)

    def hasQuadraticLLH(self) -> bool:
        """
        Checks whether the defined noise model is gaussian, i.e., the nllh
        is quadratic
        :rtype: boolean
        :return: boolean flag
        """
        return _amici.Model_hasQuadraticLLH(self)

    def getTimepoints(self) -> Tuple[float]:
        """
        Get the timepoint vector.
        :rtype: DoubleVector
        :return: Timepoint vector
        """
        return _amici.Model_getTimepoints(self)

    def getTimepoint(self, it: int) -> float:
        """
        Get simulation timepoint for time index `it`.
        :type it: int
        :param it: Time index
        :rtype: float
        :return: Timepoint
        """
        return _amici.Model_getTimepoint(self, it)

    def setTimepoints(self, ts: 'Sequence[float]'):
        """
        Set the timepoint vector.
        :type ts: DoubleVector
        :param ts: New timepoint vector
        """
        return _amici.Model_setTimepoints(self, ts)

    def t0(self) -> float:
        """
        Get simulation start time.
        :rtype: float
        :return: Simulation start time
        """
        return _amici.Model_t0(self)

    def setT0(self, t0: float):
        """
        Set simulation start time.
        :type t0: float
        :param t0: Simulation start time
        """
        return _amici.Model_setT0(self, t0)

    def getStateIsNonNegative(self) -> Tuple[bool]:
        """
        Get flags indicating whether states should be treated as
        non-negative.
        :rtype: BoolVector
        :return: Vector of flags
        """
        return _amici.Model_getStateIsNonNegative(self)

    def setStateIsNonNegative(self, stateIsNonNegative: 'BoolVector'):
        """
        Set flags indicating whether states should be treated as
        non-negative.
        :type stateIsNonNegative: BoolVector
        :param stateIsNonNegative: Vector of flags
        """
        return _amici.Model_setStateIsNonNegative(self, stateIsNonNegative)

    def setAllStatesNonNegative(self):
        """
        Set flags indicating that all states should be treated as
        non-negative.
        """
        return _amici.Model_setAllStatesNonNegative(self)

    def setMinimumSigmaResiduals(self, min_sigma: float):
        """
        Sets the estimated lower boundary for sigma_y. When
        :meth:`setAddSigmaResiduals` is activated, this lower boundary must
        ensure that log(sigma) + min_sigma > 0.
        :type min_sigma: float
        :param min_sigma: lower boundary
        """
        return _amici.Model_setMinimumSigmaResiduals(self, min_sigma)

    def getMinimumSigmaResiduals(self) -> float:
        """
        Gets the specified estimated lower boundary for sigma_y.
        :rtype: float
        :return: lower boundary
        """
        return _amici.Model_getMinimumSigmaResiduals(self)

    def setAddSigmaResiduals(self, sigma_res: bool):
        """
        Specifies whether residuals should be added to account for
        parameter dependent sigma.

        If set to true, additional residuals of the form :math:`\\sqrt{\\log(\\sigma) +C}` will be added. This enables least-squares optimization for
        variables with Gaussian noise assumption and parameter dependent standard
        deviation sigma. The constant :math:`C` can be set via
        :meth:`setMinimumSigmaResiduals`.

        :type sigma_res: boolean
        :param sigma_res: if true, additional residuals are added
        """
        return _amici.Model_setAddSigmaResiduals(self, sigma_res)

    def getAddSigmaResiduals(self) -> bool:
        """
        Checks whether residuals should be added to account for parameter
        dependent sigma.
        :rtype: boolean
        :return: sigma_res
        """
        return _amici.Model_getAddSigmaResiduals(self)

    def getParameterList(self) -> Tuple[int]:
        """
        Get the list of parameters for which sensitivities are computed.
        :rtype: IntVector
        :return: List of parameter indices
        """
        return _amici.Model_getParameterList(self)

    def plist(self, pos: int) -> int:
        """
        Get entry in parameter list by index.
        :type pos: int
        :param pos: Index in sensitivity parameter list
        :rtype: int
        :return: Index in parameter list
        """
        return _amici.Model_plist(self, pos)

    def setParameterList(self, plist: Sequence[int]):
        """
        Set the list of parameters for which sensitivities are to be
        computed.

        NOTE: Resets initial state sensitivities.

        :type plist: IntVector
        :param plist: List of parameter indices
        """
        return _amici.Model_setParameterList(self, plist)

    def getInitialStates(self) -> Tuple[float]:
        """
        Get the initial states.
        :rtype: DoubleVector
        :return: Initial state vector
        """
        return _amici.Model_getInitialStates(self)

    def setInitialStates(self, x0: 'Sequence[float]'):
        """
        Set the initial states.
        :type x0: DoubleVector
        :param x0: Initial state vector
        """
        return _amici.Model_setInitialStates(self, x0)

    def hasCustomInitialStates(self) -> bool:
        """
        Return whether custom initial states have been set.
        :rtype: boolean
        :return: `true` if has custom initial states, otherwise `false`
        """
        return _amici.Model_hasCustomInitialStates(self)

    def getInitialStateSensitivities(self) -> Tuple[float]:
        """
        Get the initial states sensitivities.
        :rtype: DoubleVector
        :return: vector of initial state sensitivities
        """
        return _amici.Model_getInitialStateSensitivities(self)

    def setInitialStateSensitivities(self, sx0: 'Sequence[float]'):
        """
        Set the initial state sensitivities.
        :type sx0: DoubleVector
        :param sx0: vector of initial state sensitivities with chainrule applied.
            This could be a slice of ReturnData::sx or ReturnData::sx0
        """
        return _amici.Model_setInitialStateSensitivities(self, sx0)

    def hasCustomInitialStateSensitivities(self) -> bool:
        """
        Return whether custom initial state sensitivities have been set.
        :rtype: boolean
        :return: `true` if has custom initial state sensitivities, otherwise
            `false`.
        """
        return _amici.Model_hasCustomInitialStateSensitivities(self)

    def setUnscaledInitialStateSensitivities(self, sx0: 'Sequence[float]'):
        """
        Set the initial state sensitivities.
        :type sx0: DoubleVector
        :param sx0: Vector of initial state sensitivities without chainrule
            applied. This could be the readin from a `model.sx0data` saved to HDF5.
        """
        return _amici.Model_setUnscaledInitialStateSensitivities(self, sx0)

    def setSteadyStateComputationMode(self, mode: 'amici::SteadyStateComputationMode'):
        """
        Set the mode how steady state is computed in the steadystate
        simulation.
        :type mode: int
        :param mode: Steadystate computation mode
        """
        return _amici.Model_setSteadyStateComputationMode(self, mode)

    def getSteadyStateComputationMode(self) -> 'amici::SteadyStateComputationMode':
        """
        Gets the mode how steady state is computed in the steadystate
        simulation.
        :rtype: int
        :return: Mode
        """
        return _amici.Model_getSteadyStateComputationMode(self)

    def setSteadyStateSensitivityMode(self, mode: 'SteadyStateSensitivityMode'):
        """
        Set the mode how sensitivities are computed in the steadystate
        simulation.
        :type mode: SteadyStateSensitivityMode
        :param mode: Steadystate sensitivity mode
        """
        return _amici.Model_setSteadyStateSensitivityMode(self, mode)

    def getSteadyStateSensitivityMode(self) -> 'SteadyStateSensitivityMode':
        """
        Gets the mode how sensitivities are computed in the steadystate
        simulation.
        :rtype: SteadyStateSensitivityMode
        :return: Mode
        """
        return _amici.Model_getSteadyStateSensitivityMode(self)

    def setReinitializeFixedParameterInitialStates(self, flag: bool):
        """
        Set whether initial states depending on fixed parameters are to be
        reinitialized after preequilibration and presimulation.
        :type flag: boolean
        :param flag: Fixed parameters reinitialized?
        """
        return _amici.Model_setReinitializeFixedParameterInitialStates(self, flag)

    def getReinitializeFixedParameterInitialStates(self) -> bool:
        """
        Get whether initial states depending on fixedParameters are to be
        reinitialized after preequilibration and presimulation.
        :rtype: boolean
        :return: flag `true` / `false`
        """
        return _amici.Model_getReinitializeFixedParameterInitialStates(self)

    def requireSensitivitiesForAllParameters(self):
        """
        Require computation of sensitivities for all parameters p [0..np[
        in natural order.

        NOTE: Resets initial state sensitivities.
        """
        return _amici.Model_requireSensitivitiesForAllParameters(self)

    def getObservableScaling(self, iy: int) -> 'ObservableScaling':
        """
        Get scaling type for observable
        :type iy: int
        :param iy: observable index
        :rtype: int
        :return: scaling type
        """
        return _amici.Model_getObservableScaling(self, iy)

    def setAlwaysCheckFinite(self, alwaysCheck: bool):
        """
        Set whether the result of every call to `Model::f*` should be
        checked for finiteness.
        :type alwaysCheck: boolean
        :param alwaysCheck:
        """
        return _amici.Model_setAlwaysCheckFinite(self, alwaysCheck)

    def getAlwaysCheckFinite(self) -> bool:
        """
        Get setting of whether the result of every call to `Model::f*`
        should be checked for finiteness.
        :rtype: boolean
        :return: that
        """
        return _amici.Model_getAlwaysCheckFinite(self)

    def setReinitializationStateIdxs(self, idxs: Sequence[int]):
        """
        Set indices of states to be reinitialized based on provided
        constants / fixed parameters
        :type idxs: IntVector
        :param idxs: Array of state indices
        """
        return _amici.Model_setReinitializationStateIdxs(self, idxs)

    def getReinitializationStateIdxs(self) -> Tuple[int]:
        """
        Return indices of states to be reinitialized based on provided
        constants / fixed parameters
        :rtype: IntVector
        :return: Those indices.
        """
        return _amici.Model_getReinitializationStateIdxs(self)
    pythonGenerated = property(_amici.Model_pythonGenerated_get, _amici.Model_pythonGenerated_set, doc=' Flag indicating Matlab- or Python-based model generation')
    o2mode = property(_amici.Model_o2mode_get, _amici.Model_o2mode_set, doc='\n    Flag indicating whether for\n    `amici::Solver::sensi_` == `amici::SensitivityOrder::second`\n    directional or full second order derivative will be computed\n    ')
    idlist = property(_amici.Model_idlist_get, _amici.Model_idlist_set, doc=' Flag array for DAE equations')
    logger = property(_amici.Model_logger_get, _amici.Model_logger_set, doc=' Logger')

    def setParameterScale(self, *args):
        return _amici.Model_setParameterScale(self, *args)
_amici.Model_swigregister(Model)
model_quantity_to_str = cvar.model_quantity_to_str

def equals(*args) -> bool:
    """
    *Overload 1:*

    Check equality of data members excluding solver memory
    :type a: :py:class:`Solver`
    :param a:
    :type b: :py:class:`Solver`
    :param b:
    :rtype: boolean
    :return: 

    |

    *Overload 2:*

    Equality operator
    :type a: :py:class:`CVodeSolver`
    :param a:
    :type b: :py:class:`CVodeSolver`
    :param b:
    :rtype: boolean
    :return: Whether a and b are equal

    |

    *Overload 3:*

    Check equality of data members.
    :type a: :py:class:`Model`
    :param a: First model instance
    :type b: :py:class:`Model`
    :param b: Second model instance
    :rtype: boolean
    :return: Equality
    """
    return _amici.equals(*args)

def __eq__(*args) -> bool:
    return _amici.__eq__(*args)

class Model_ODE(Model):
    """
    The Model class represents an AMICI ODE model.

    The model does not contain any data, but represents the state
    of the model at a specific time t. The states must not always be
    in sync, but may be updated asynchronously.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr

    def getSolver(self) -> 'Solver':
        return _amici.Model_ODE_getSolver(self)
    __swig_destroy__ = _amici.delete_Model_ODE
_amici.Model_ODE_swigregister(Model_ODE)

class Model_DAE(Model):
    """
    The Model class represents an AMICI DAE model.

    The model does not contain any data, but represents the state
    of the model at a specific time t. The states must not always be
    in sync, but may be updated asynchronously.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr

    def getSolver(self) -> 'Solver':
        return _amici.Model_DAE_getSolver(self)
    __swig_destroy__ = _amici.delete_Model_DAE
_amici.Model_DAE_swigregister(Model_DAE)
LogSeverity_error = _amici.LogSeverity_error
LogSeverity_warning = _amici.LogSeverity_warning
LogSeverity_debug = _amici.LogSeverity_debug

class LogItem(object):
    """A log item."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Default ctor.

        |

        *Overload 2:*

        Construct a LogItem
        :type severity: int
        :param severity:
        :type identifier: str
        :param identifier:
        :type message: str
        :param message:
        """
        _amici.LogItem_swiginit(self, _amici.new_LogItem(*args))
    severity = property(_amici.LogItem_severity_get, _amici.LogItem_severity_set, doc=' Severity level')
    identifier = property(_amici.LogItem_identifier_get, _amici.LogItem_identifier_set, doc=' Short identifier for the logged event')
    message = property(_amici.LogItem_message_get, _amici.LogItem_message_set, doc=' A more detailed and readable message')
    __swig_destroy__ = _amici.delete_LogItem
_amici.LogItem_swigregister(LogItem)

class ReturnData(ModelDimensions):
    """
    Stores all data to be returned by amici::runAmiciSimulation.

    NOTE: multi-dimensional arrays are stored in row-major order (C-style)
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Default constructor

        |

        *Overload 2:*

        Constructor
        :type ts: DoubleVector
        :param ts: see amici::SimulationParameters::ts
        :type model_dimensions: :py:class:`ModelDimensions`
        :param model_dimensions: Model dimensions
        :type nplist: int
        :param nplist: see amici::ModelDimensions::nplist
        :type nmaxevent: int
        :param nmaxevent: see amici::ModelDimensions::nmaxevent
        :type nt: int
        :param nt: see amici::ModelDimensions::nt
        :type newton_maxsteps: int
        :param newton_maxsteps: see amici::Solver::newton_maxsteps
        :type pscale: ParameterScalingVector
        :param pscale: see amici::SimulationParameters::pscale
        :type o2mode: int
        :param o2mode: see amici::SimulationParameters::o2mode
        :type sensi: SensitivityOrder
        :param sensi: see amici::Solver::sensi
        :type sensi_meth: SensitivityMethod
        :param sensi_meth: see amici::Solver::sensi_meth
        :type rdrm: RDataReporting
        :param rdrm: see amici::Solver::rdata_reporting
        :type quadratic_llh: boolean
        :param quadratic_llh: whether model defines a quadratic nllh and
            computing res, sres and FIM makes sense
        :type sigma_res: boolean
        :param sigma_res: indicates whether additional residuals are to be added
            for each sigma
        :type sigma_offset: float
        :param sigma_offset: offset to ensure real-valuedness of sigma residuals

        |

        *Overload 3:*

        constructor that uses information from model and solver to
        appropriately initialize fields
        :type solver: :py:class:`Solver`
        :param solver: solver instance
        :type model: :py:class:`Model`
        :param model: model instance
        """
        _amici.ReturnData_swiginit(self, _amici.new_ReturnData(*args))
    __swig_destroy__ = _amici.delete_ReturnData
    id = property(_amici.ReturnData_id_get, _amici.ReturnData_id_set, doc='Arbitrary (not necessarily unique) identifier.')
    ts = property(_amici.ReturnData_ts_get, _amici.ReturnData_ts_set, doc='timepoints (shape `nt`)')
    xdot = property(_amici.ReturnData_xdot_get, _amici.ReturnData_xdot_set, doc=' time derivative (shape `nx`)')
    J = property(_amici.ReturnData_J_get, _amici.ReturnData_J_set, doc='\n    Jacobian of differential equation right hand side (shape `nx` x `nx`,\n    row-major)\n    ')
    w = property(_amici.ReturnData_w_get, _amici.ReturnData_w_set, doc='\n    w data from the model (recurring terms in xdot, for imported SBML models\n    from python, this contains the flux vector) (shape `nt` x `nw`, row\n    major)\n    ')
    z = property(_amici.ReturnData_z_get, _amici.ReturnData_z_set, doc=' event output (shape `nmaxevent` x `nz`, row-major)')
    sigmaz = property(_amici.ReturnData_sigmaz_get, _amici.ReturnData_sigmaz_set, doc='\n    event output sigma standard deviation (shape `nmaxevent` x `nz`,\n    row-major)\n    ')
    sz = property(_amici.ReturnData_sz_get, _amici.ReturnData_sz_set, doc='\n    parameter derivative of event output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    ssigmaz = property(_amici.ReturnData_ssigmaz_get, _amici.ReturnData_ssigmaz_set, doc='\n    parameter derivative of event output standard deviation\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    rz = property(_amici.ReturnData_rz_get, _amici.ReturnData_rz_set, doc=' event trigger output (shape `nmaxevent` x `nz`, row-major)')
    srz = property(_amici.ReturnData_srz_get, _amici.ReturnData_srz_set, doc='\n    parameter derivative of event trigger output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    s2rz = property(_amici.ReturnData_s2rz_get, _amici.ReturnData_s2rz_set, doc='\n    second-order parameter derivative of event trigger output (shape\n    `nmaxevent` x `nztrue` x `nplist` x `nplist`, row-major)\n    ')
    x = property(_amici.ReturnData_x_get, _amici.ReturnData_x_set, doc=' state (shape `nt` x `nx`, row-major)')
    sx = property(_amici.ReturnData_sx_get, _amici.ReturnData_sx_set, doc='parameter derivative of state (shape `nt` x `nplist` x `nx`, row-major)')
    y = property(_amici.ReturnData_y_get, _amici.ReturnData_y_set, doc=' observable (shape `nt` x `ny`, row-major)')
    sigmay = property(_amici.ReturnData_sigmay_get, _amici.ReturnData_sigmay_set, doc=' observable standard deviation (shape `nt` x `ny`, row-major)')
    sy = property(_amici.ReturnData_sy_get, _amici.ReturnData_sy_set, doc='\n    parameter derivative of observable (shape `nt` x `nplist` x `ny`,\n    row-major)\n    ')
    ssigmay = property(_amici.ReturnData_ssigmay_get, _amici.ReturnData_ssigmay_set, doc='\n    parameter derivative of observable standard deviation\n    (shape `nt` x `nplist` x `ny`, row-major)\n    ')
    res = property(_amici.ReturnData_res_get, _amici.ReturnData_res_set, doc=' observable (shape `nt*ny`, row-major)')
    sres = property(_amici.ReturnData_sres_get, _amici.ReturnData_sres_set, doc='parameter derivative of residual (shape `nt*ny` x `nplist`, row-major)')
    FIM = property(_amici.ReturnData_FIM_get, _amici.ReturnData_FIM_set, doc=' fisher information matrix (shape `nplist` x `nplist`, row-major)')
    numsteps = property(_amici.ReturnData_numsteps_get, _amici.ReturnData_numsteps_set, doc=' number of integration steps forward problem (shape `nt`)')
    numstepsB = property(_amici.ReturnData_numstepsB_get, _amici.ReturnData_numstepsB_set, doc=' number of integration steps backward problem (shape `nt`)')
    numrhsevals = property(_amici.ReturnData_numrhsevals_get, _amici.ReturnData_numrhsevals_set, doc=' number of right hand side evaluations forward problem (shape `nt`)')
    numrhsevalsB = property(_amici.ReturnData_numrhsevalsB_get, _amici.ReturnData_numrhsevalsB_set, doc=' number of right hand side evaluations backward problem (shape `nt`)')
    numerrtestfails = property(_amici.ReturnData_numerrtestfails_get, _amici.ReturnData_numerrtestfails_set, doc=' number of error test failures forward problem (shape `nt`)')
    numerrtestfailsB = property(_amici.ReturnData_numerrtestfailsB_get, _amici.ReturnData_numerrtestfailsB_set, doc=' number of error test failures backward problem (shape `nt`)')
    numnonlinsolvconvfails = property(_amici.ReturnData_numnonlinsolvconvfails_get, _amici.ReturnData_numnonlinsolvconvfails_set, doc='number of linear solver convergence failures forward problem (shape `nt`)')
    numnonlinsolvconvfailsB = property(_amici.ReturnData_numnonlinsolvconvfailsB_get, _amici.ReturnData_numnonlinsolvconvfailsB_set, doc='\n    number of linear solver convergence failures backward problem (shape\n    `nt`)\n    ')
    order = property(_amici.ReturnData_order_get, _amici.ReturnData_order_set, doc=' employed order forward problem (shape `nt`)')
    cpu_time = property(_amici.ReturnData_cpu_time_get, _amici.ReturnData_cpu_time_set, doc='\n    computation time of forward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_timeB = property(_amici.ReturnData_cpu_timeB_get, _amici.ReturnData_cpu_timeB_set, doc='\n    computation time of backward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_time_total = property(_amici.ReturnData_cpu_time_total_get, _amici.ReturnData_cpu_time_total_set, doc='\n    total CPU time from entering runAmiciSimulation until exiting [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_status = property(_amici.ReturnData_preeq_status_get, _amici.ReturnData_preeq_status_set, doc=' flags indicating success of steady state solver (preequilibration)')
    preeq_cpu_time = property(_amici.ReturnData_preeq_cpu_time_get, _amici.ReturnData_preeq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_cpu_timeB = property(_amici.ReturnData_preeq_cpu_timeB_get, _amici.ReturnData_preeq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_status = property(_amici.ReturnData_posteq_status_get, _amici.ReturnData_posteq_status_set, doc=' flags indicating success of steady state solver  (postequilibration)')
    posteq_cpu_time = property(_amici.ReturnData_posteq_cpu_time_get, _amici.ReturnData_posteq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_cpu_timeB = property(_amici.ReturnData_posteq_cpu_timeB_get, _amici.ReturnData_posteq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_numsteps = property(_amici.ReturnData_preeq_numsteps_get, _amici.ReturnData_preeq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (length = 3)\n    ')
    preeq_numstepsB = property(_amici.ReturnData_preeq_numstepsB_get, _amici.ReturnData_preeq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (preequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    posteq_numsteps = property(_amici.ReturnData_posteq_numsteps_get, _amici.ReturnData_posteq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (shape `3`) (postequilibration)\n    ')
    posteq_numstepsB = property(_amici.ReturnData_posteq_numstepsB_get, _amici.ReturnData_posteq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (postequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    preeq_t = property(_amici.ReturnData_preeq_t_get, _amici.ReturnData_preeq_t_set, doc='time when steadystate was reached via simulation (preequilibration)')
    preeq_wrms = property(_amici.ReturnData_preeq_wrms_get, _amici.ReturnData_preeq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (preequilibration)\n    ')
    posteq_t = property(_amici.ReturnData_posteq_t_get, _amici.ReturnData_posteq_t_set, doc='time when steadystate was reached via simulation (postequilibration)')
    posteq_wrms = property(_amici.ReturnData_posteq_wrms_get, _amici.ReturnData_posteq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (postequilibration)\n    ')
    x0 = property(_amici.ReturnData_x0_get, _amici.ReturnData_x0_set, doc=' initial state (shape `nx`)')
    x_ss = property(_amici.ReturnData_x_ss_get, _amici.ReturnData_x_ss_set, doc=' preequilibration steady state (shape `nx`)')
    sx0 = property(_amici.ReturnData_sx0_get, _amici.ReturnData_sx0_set, doc=' initial sensitivities (shape `nplist` x `nx`, row-major)')
    sx_ss = property(_amici.ReturnData_sx_ss_get, _amici.ReturnData_sx_ss_set, doc='\n    preequilibration sensitivities\n    (shape `nplist` x `nx`, row-major)\n    ')
    llh = property(_amici.ReturnData_llh_get, _amici.ReturnData_llh_set, doc=' log-likelihood value')
    chi2 = property(_amici.ReturnData_chi2_get, _amici.ReturnData_chi2_set, doc=' :math:`\\chi^2` value')
    sllh = property(_amici.ReturnData_sllh_get, _amici.ReturnData_sllh_set, doc=' parameter derivative of log-likelihood (shape `nplist`)')
    s2llh = property(_amici.ReturnData_s2llh_get, _amici.ReturnData_s2llh_set, doc='\n    second-order parameter derivative of log-likelihood\n    (shape `nJ-1` x `nplist`, row-major)\n    ')
    status = property(_amici.ReturnData_status_get, _amici.ReturnData_status_set, doc='\n    Simulation status code.\n\n    One of:\n\n    * AMICI_SUCCESS, indicating successful simulation\n    * AMICI_MAX_TIME_EXCEEDED, indicating that the simulation did not finish\n      within the allowed time (see Solver.{set,get}MaxTime)\n    * AMICI_ERROR, indicating that some error occurred during simulation\n      (a more detailed error message will have been printed).\n    * AMICI_NOT_RUN, if no simulation was started\n    ')
    nx = property(_amici.ReturnData_nx_get, _amici.ReturnData_nx_set, doc=' number of states (alias `nx_rdata`, kept for backward compatibility)')
    nxtrue = property(_amici.ReturnData_nxtrue_get, _amici.ReturnData_nxtrue_set, doc='\n    number of states in the unaugmented system\n    (alias nxtrue_rdata, kept for backward compatibility)\n    ')
    nplist = property(_amici.ReturnData_nplist_get, _amici.ReturnData_nplist_set, doc=' number of parameter for which sensitivities were requested')
    nmaxevent = property(_amici.ReturnData_nmaxevent_get, _amici.ReturnData_nmaxevent_set, doc=' maximal number of occurring events (for every event type)')
    nt = property(_amici.ReturnData_nt_get, _amici.ReturnData_nt_set, doc=' number of considered timepoints')
    newton_maxsteps = property(_amici.ReturnData_newton_maxsteps_get, _amici.ReturnData_newton_maxsteps_set, doc=' maximal number of newton iterations for steady state calculation')
    pscale = property(_amici.ReturnData_pscale_get, _amici.ReturnData_pscale_set, doc=' scaling of parameterization')
    o2mode = property(_amici.ReturnData_o2mode_get, _amici.ReturnData_o2mode_set, doc=' flag indicating whether second-order sensitivities were requested')
    sensi = property(_amici.ReturnData_sensi_get, _amici.ReturnData_sensi_set, doc=' sensitivity order')
    sensi_meth = property(_amici.ReturnData_sensi_meth_get, _amici.ReturnData_sensi_meth_set, doc=' sensitivity method')
    rdata_reporting = property(_amici.ReturnData_rdata_reporting_get, _amici.ReturnData_rdata_reporting_set, doc=' reporting mode')
    sigma_res = property(_amici.ReturnData_sigma_res_get, _amici.ReturnData_sigma_res_set, doc='\n     boolean indicating whether residuals for standard deviations have been\n    added\n    ')
    messages = property(_amici.ReturnData_messages_get, _amici.ReturnData_messages_set, doc=' log messages')
_amici.ReturnData_swigregister(ReturnData)

def writeSolverSettingsToHDF5(*args):
    """
    *Overload 1:*

    Write solver options to HDF5 file.
    :type hdf5Filename: str
    :param hdf5Filename: Name of HDF5 file to write to
    :type solver: :py:class:`Solver`
    :param solver: Solver to write options from
    :type hdf5Location: str
    :param hdf5Location: Path inside the HDF5 file

    |

    *Overload 2:*

    Write solver options to HDF5 file.
    :type file: H5::H5File
    :param file: File to read from
    :type solver: :py:class:`Solver`
    :param solver: Solver to write options from
    :type hdf5Location: str
    :param hdf5Location: Path inside the HDF5 file
    """
    return _amici.writeSolverSettingsToHDF5(*args)

def readSolverSettingsFromHDF5(*args):
    """
    *Overload 1:*

    Read solver options from HDF5 file.
    :type file: H5::H5File
    :param file: HDF5 file to read from
    :type solver: :py:class:`Solver`
    :param solver: Solver to set options on
    :type datasetPath: str
    :param datasetPath: Path inside the HDF5 file

    |

    *Overload 2:*

    Read solver options from HDF5 file.
    :type hdffile: str
    :param hdffile: Name of HDF5 file
    :type solver: :py:class:`Solver`
    :param solver: Solver to set options on
    :type datasetPath: str
    :param datasetPath: Path inside the HDF5 file
    """
    return _amici.readSolverSettingsFromHDF5(*args)

def readModelDataFromHDF5(*args):
    """
    *Overload 1:*

    Read model data from HDF5 file.
    :type hdffile: str
    :param hdffile: Name of HDF5 file
    :type model: :py:class:`Model`
    :param model: Model to set data on
    :type datasetPath: str
    :param datasetPath: Path inside the HDF5 file

    |

    *Overload 2:*

    Read model data from HDF5 file.
    :type file: H5::H5File
    :param file: HDF5 file handle to read from
    :type model: :py:class:`Model`
    :param model: Model to set data on
    :type datasetPath: str
    :param datasetPath: Path inside the HDF5 file
    """
    return _amici.readModelDataFromHDF5(*args)

def writeReturnData(*args):
    """
    *Overload 1:*

    Write ReturnData to HDF5 file.
    :type rdata: :py:class:`ReturnData`
    :param rdata: Data to write
    :type file: H5::H5File
    :param file: HDF5 file to write to
    :type hdf5Location: str
    :param hdf5Location: Full dataset path inside the HDF5 file (will be created)

    |

    *Overload 2:*

    Write ReturnData to HDF5 file.
    :type rdata: :py:class:`ReturnData`
    :param rdata: Data to write
    :type hdf5Filename: str
    :param hdf5Filename: Filename of HDF5 file
    :type hdf5Location: str
    :param hdf5Location: Full dataset path inside the HDF5 file (will be created)
    """
    return _amici.writeReturnData(*args)

def readSimulationExpData(hdf5Filename: str, hdf5Root: str, model: 'Model') -> 'ExpData':
    """
    Read AMICI ExpData data from HDF5 file.
    :type hdf5Filename: str
    :param hdf5Filename: Name of HDF5 file
    :type hdf5Root: str
    :param hdf5Root: Path inside the HDF5 file to object having ExpData
    :type model: :py:class:`Model`
    :param model: The model for which data is to be read
    :rtype: ExpData
    :return: ExpData created from data in the given location
    """
    return _amici.readSimulationExpData(hdf5Filename, hdf5Root, model)

def writeSimulationExpData(edata: 'ExpData', file: 'H5::H5File const &', hdf5Location: str):
    """
    Write AMICI experimental data to HDF5 file.
    :type edata: :py:class:`ExpData`
    :param edata: The experimental data which is to be written
    :type file: H5::H5File
    :param file: Name of HDF5 file
    :type hdf5Location: str
    :param hdf5Location: Path inside the HDF5 file to object having ExpData
    """
    return _amici.writeSimulationExpData(edata, file, hdf5Location)

def runAmiciSimulation(solver: 'Solver', edata: 'ExpData', model: 'Model', rethrow: bool=False) -> 'ReturnData':
    """
    Core integration routine. Initializes the solver and runs the forward
    and backward problem.

    :type solver: :py:class:`Solver`
    :param solver: Solver instance
    :type edata: :py:class:`ExpData`
    :param edata: pointer to experimental data object
    :type model: :py:class:`Model`
    :param model: model specification object
    :type rethrow: boolean, optional
    :param rethrow: rethrow integration exceptions?
    :rtype: ReturnData
    :return: rdata pointer to return data object
    """
    return _amici.runAmiciSimulation(solver, edata, model, rethrow)

def runAmiciSimulations(solver: 'Solver', edatas: 'ExpDataPtrVector', model: 'Model', failfast: bool, num_threads: int) -> Tuple['ReturnData']:
    """
    Same as runAmiciSimulation, but for multiple ExpData instances. When
    compiled with OpenMP support, this function runs multi-threaded.

    :type solver: :py:class:`Solver`
    :param solver: Solver instance
    :type edatas: ExpDataPtrVector
    :param edatas: experimental data objects
    :type model: :py:class:`Model`
    :param model: model specification object
    :type failfast: boolean
    :param failfast: flag to allow early termination
    :type num_threads: int
    :param num_threads: number of threads for parallel execution
    :rtype: Iterable[ReturnData]
    :return: vector of pointers to return data objects
    """
    return _amici.runAmiciSimulations(solver, edatas, model, failfast, num_threads)

def simulation_status_to_str(status: int) -> str:
    """
    Get the string representation of the given simulation status code
    (see ReturnData::status).
    :type status: int
    :param status: Status code
    :rtype: str
    :return: Name of the variable representing this status code.
    """
    return _amici.simulation_status_to_str(status)

class ExpDataPtrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.ExpDataPtrVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.ExpDataPtrVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.ExpDataPtrVector___bool__(self)

    def __len__(self) -> int:
        return _amici.ExpDataPtrVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< amici::ExpData *,std::allocator< amici::ExpData * > > *':
        return _amici.ExpDataPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.ExpDataPtrVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.ExpDataPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.ExpDataPtrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> 'std::vector< amici::ExpData * >::value_type':
        return _amici.ExpDataPtrVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.ExpDataPtrVector___setitem__(self, *args)

    def pop(self) -> 'std::vector< amici::ExpData * >::value_type':
        return _amici.ExpDataPtrVector_pop(self)

    def append(self, x: 'ExpData'):
        return _amici.ExpDataPtrVector_append(self, x)

    def empty(self) -> bool:
        return _amici.ExpDataPtrVector_empty(self)

    def size(self) -> int:
        return _amici.ExpDataPtrVector_size(self)

    def swap(self, v: 'ExpDataPtrVector'):
        return _amici.ExpDataPtrVector_swap(self, v)

    def begin(self) -> 'std::vector< amici::ExpData * >::iterator':
        return _amici.ExpDataPtrVector_begin(self)

    def end(self) -> 'std::vector< amici::ExpData * >::iterator':
        return _amici.ExpDataPtrVector_end(self)

    def rbegin(self) -> 'std::vector< amici::ExpData * >::reverse_iterator':
        return _amici.ExpDataPtrVector_rbegin(self)

    def rend(self) -> 'std::vector< amici::ExpData * >::reverse_iterator':
        return _amici.ExpDataPtrVector_rend(self)

    def clear(self):
        return _amici.ExpDataPtrVector_clear(self)

    def get_allocator(self) -> 'std::vector< amici::ExpData * >::allocator_type':
        return _amici.ExpDataPtrVector_get_allocator(self)

    def pop_back(self):
        return _amici.ExpDataPtrVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< amici::ExpData * >::iterator':
        return _amici.ExpDataPtrVector_erase(self, *args)

    def __init__(self, *args):
        _amici.ExpDataPtrVector_swiginit(self, _amici.new_ExpDataPtrVector(*args))

    def push_back(self, x: 'ExpData'):
        return _amici.ExpDataPtrVector_push_back(self, x)

    def front(self) -> 'std::vector< amici::ExpData * >::value_type':
        return _amici.ExpDataPtrVector_front(self)

    def back(self) -> 'std::vector< amici::ExpData * >::value_type':
        return _amici.ExpDataPtrVector_back(self)

    def assign(self, n: int, x: 'ExpData'):
        return _amici.ExpDataPtrVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.ExpDataPtrVector_resize(self, *args)

    def insert(self, *args):
        return _amici.ExpDataPtrVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.ExpDataPtrVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.ExpDataPtrVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_ExpDataPtrVector
_amici.ExpDataPtrVector_swigregister(ExpDataPtrVector)

class LogItemVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.LogItemVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.LogItemVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.LogItemVector___bool__(self)

    def __len__(self) -> int:
        return _amici.LogItemVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< amici::LogItem,std::allocator< amici::LogItem > > *':
        return _amici.LogItemVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.LogItemVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.LogItemVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.LogItemVector___delitem__(self, *args)

    def __getitem__(self, *args) -> 'std::vector< amici::LogItem >::value_type const &':
        return _amici.LogItemVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.LogItemVector___setitem__(self, *args)

    def pop(self) -> 'std::vector< amici::LogItem >::value_type':
        return _amici.LogItemVector_pop(self)

    def append(self, x: 'LogItem'):
        return _amici.LogItemVector_append(self, x)

    def empty(self) -> bool:
        return _amici.LogItemVector_empty(self)

    def size(self) -> int:
        return _amici.LogItemVector_size(self)

    def swap(self, v: 'LogItemVector'):
        return _amici.LogItemVector_swap(self, v)

    def begin(self) -> 'std::vector< amici::LogItem >::iterator':
        return _amici.LogItemVector_begin(self)

    def end(self) -> 'std::vector< amici::LogItem >::iterator':
        return _amici.LogItemVector_end(self)

    def rbegin(self) -> 'std::vector< amici::LogItem >::reverse_iterator':
        return _amici.LogItemVector_rbegin(self)

    def rend(self) -> 'std::vector< amici::LogItem >::reverse_iterator':
        return _amici.LogItemVector_rend(self)

    def clear(self):
        return _amici.LogItemVector_clear(self)

    def get_allocator(self) -> 'std::vector< amici::LogItem >::allocator_type':
        return _amici.LogItemVector_get_allocator(self)

    def pop_back(self):
        return _amici.LogItemVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< amici::LogItem >::iterator':
        return _amici.LogItemVector_erase(self, *args)

    def __init__(self, *args):
        _amici.LogItemVector_swiginit(self, _amici.new_LogItemVector(*args))

    def push_back(self, x: 'LogItem'):
        return _amici.LogItemVector_push_back(self, x)

    def front(self) -> 'std::vector< amici::LogItem >::value_type const &':
        return _amici.LogItemVector_front(self)

    def back(self) -> 'std::vector< amici::LogItem >::value_type const &':
        return _amici.LogItemVector_back(self)

    def assign(self, n: int, x: 'LogItem'):
        return _amici.LogItemVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.LogItemVector_resize(self, *args)

    def insert(self, *args):
        return _amici.LogItemVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.LogItemVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.LogItemVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_LogItemVector
_amici.LogItemVector_swigregister(LogItemVector)

def parameterScalingFromIntVector(intVec: Sequence[int]) -> Tuple['ParameterScaling']:
    """
    Swig-Generated class, which, in contrast to other Vector
    classes, does not allow for simple interoperability with common
    Python types, but must be created using
    :func:`amici.amici.parameterScalingFromIntVector`
    """
    return _amici.parameterScalingFromIntVector(intVec)

class ParameterScalingVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.ParameterScalingVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.ParameterScalingVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.ParameterScalingVector___bool__(self)

    def __len__(self) -> int:
        return _amici.ParameterScalingVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< amici::ParameterScaling,std::allocator< amici::ParameterScaling > > *':
        return _amici.ParameterScalingVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.ParameterScalingVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.ParameterScalingVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.ParameterScalingVector___delitem__(self, *args)

    def __getitem__(self, *args) -> 'std::vector< enum amici::ParameterScaling >::value_type const &':
        return _amici.ParameterScalingVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.ParameterScalingVector___setitem__(self, *args)

    def pop(self) -> 'std::vector< enum amici::ParameterScaling >::value_type':
        return _amici.ParameterScalingVector_pop(self)

    def append(self, x: 'std::vector< enum amici::ParameterScaling >::value_type const &'):
        return _amici.ParameterScalingVector_append(self, x)

    def empty(self) -> bool:
        return _amici.ParameterScalingVector_empty(self)

    def size(self) -> int:
        return _amici.ParameterScalingVector_size(self)

    def swap(self, v: 'ParameterScalingVector'):
        return _amici.ParameterScalingVector_swap(self, v)

    def begin(self) -> 'std::vector< enum amici::ParameterScaling >::iterator':
        return _amici.ParameterScalingVector_begin(self)

    def end(self) -> 'std::vector< enum amici::ParameterScaling >::iterator':
        return _amici.ParameterScalingVector_end(self)

    def rbegin(self) -> 'std::vector< enum amici::ParameterScaling >::reverse_iterator':
        return _amici.ParameterScalingVector_rbegin(self)

    def rend(self) -> 'std::vector< enum amici::ParameterScaling >::reverse_iterator':
        return _amici.ParameterScalingVector_rend(self)

    def clear(self):
        return _amici.ParameterScalingVector_clear(self)

    def get_allocator(self) -> 'std::vector< enum amici::ParameterScaling >::allocator_type':
        return _amici.ParameterScalingVector_get_allocator(self)

    def pop_back(self):
        return _amici.ParameterScalingVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< enum amici::ParameterScaling >::iterator':
        return _amici.ParameterScalingVector_erase(self, *args)

    def __init__(self, *args):
        _amici.ParameterScalingVector_swiginit(self, _amici.new_ParameterScalingVector(*args))

    def push_back(self, x: 'std::vector< enum amici::ParameterScaling >::value_type const &'):
        return _amici.ParameterScalingVector_push_back(self, x)

    def front(self) -> 'std::vector< enum amici::ParameterScaling >::value_type const &':
        return _amici.ParameterScalingVector_front(self)

    def back(self) -> 'std::vector< enum amici::ParameterScaling >::value_type const &':
        return _amici.ParameterScalingVector_back(self)

    def assign(self, n: int, x: 'std::vector< enum amici::ParameterScaling >::value_type const &'):
        return _amici.ParameterScalingVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.ParameterScalingVector_resize(self, *args)

    def insert(self, *args):
        return _amici.ParameterScalingVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.ParameterScalingVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.ParameterScalingVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_ParameterScalingVector
_amici.ParameterScalingVector_swigregister(ParameterScalingVector)

def compiledWithOpenMP() -> bool:
    """AMICI extension was compiled with OpenMP?"""
    return _amici.compiledWithOpenMP()
from enum import IntEnum

def enum(prefix):
    values = {k: v for (k, v) in globals().items() if k.startswith(prefix + '_')}
    values = {k[len(prefix) + 1:]: v for (k, v) in values.items()}
    return IntEnum(prefix, values)
ParameterScaling = enum('ParameterScaling')
ObservableScaling = enum('ObservableScaling')
SecondOrderMode = enum('SecondOrderMode')
SensitivityOrder = enum('SensitivityOrder')
SensitivityMethod = enum('SensitivityMethod')
LinearSolver = enum('LinearSolver')
InternalSensitivityMethod = enum('InternalSensitivityMethod')
InterpolationType = enum('InterpolationType')
LinearMultistepMethod = enum('LinearMultistepMethod')
NonlinearSolverIteration = enum('NonlinearSolverIteration')
SteadyStateComputationMode = enum('SteadyStateComputationMode')
SteadyStateSensitivityMode = enum('SteadyStateSensitivityMode')
SteadyStateStatus = enum('SteadyStateStatus')
NewtonDampingFactorMode = enum('NewtonDampingFactorMode')
FixedParameterContext = enum('FixedParameterContext')
RDataReporting = enum('RDataReporting')

class SteadyStateStatusVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> 'swig::SwigPyIterator *':
        return _amici.SteadyStateStatusVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _amici.SteadyStateStatusVector___nonzero__(self)

    def __bool__(self) -> bool:
        return _amici.SteadyStateStatusVector___bool__(self)

    def __len__(self) -> int:
        return _amici.SteadyStateStatusVector___len__(self)

    def __getslice__(self, i: int, j: int) -> 'std::vector< amici::SteadyStateStatus,std::allocator< amici::SteadyStateStatus > > *':
        return _amici.SteadyStateStatusVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.SteadyStateStatusVector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int):
        return _amici.SteadyStateStatusVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.SteadyStateStatusVector___delitem__(self, *args)

    def __getitem__(self, *args) -> 'std::vector< enum amici::SteadyStateStatus >::value_type const &':
        return _amici.SteadyStateStatusVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.SteadyStateStatusVector___setitem__(self, *args)

    def pop(self) -> 'std::vector< enum amici::SteadyStateStatus >::value_type':
        return _amici.SteadyStateStatusVector_pop(self)

    def append(self, x: 'std::vector< enum amici::SteadyStateStatus >::value_type const &'):
        return _amici.SteadyStateStatusVector_append(self, x)

    def empty(self) -> bool:
        return _amici.SteadyStateStatusVector_empty(self)

    def size(self) -> int:
        return _amici.SteadyStateStatusVector_size(self)

    def swap(self, v: 'SteadyStateStatusVector'):
        return _amici.SteadyStateStatusVector_swap(self, v)

    def begin(self) -> 'std::vector< enum amici::SteadyStateStatus >::iterator':
        return _amici.SteadyStateStatusVector_begin(self)

    def end(self) -> 'std::vector< enum amici::SteadyStateStatus >::iterator':
        return _amici.SteadyStateStatusVector_end(self)

    def rbegin(self) -> 'std::vector< enum amici::SteadyStateStatus >::reverse_iterator':
        return _amici.SteadyStateStatusVector_rbegin(self)

    def rend(self) -> 'std::vector< enum amici::SteadyStateStatus >::reverse_iterator':
        return _amici.SteadyStateStatusVector_rend(self)

    def clear(self):
        return _amici.SteadyStateStatusVector_clear(self)

    def get_allocator(self) -> 'std::vector< enum amici::SteadyStateStatus >::allocator_type':
        return _amici.SteadyStateStatusVector_get_allocator(self)

    def pop_back(self):
        return _amici.SteadyStateStatusVector_pop_back(self)

    def erase(self, *args) -> 'std::vector< enum amici::SteadyStateStatus >::iterator':
        return _amici.SteadyStateStatusVector_erase(self, *args)

    def __init__(self, *args):
        _amici.SteadyStateStatusVector_swiginit(self, _amici.new_SteadyStateStatusVector(*args))

    def push_back(self, x: 'std::vector< enum amici::SteadyStateStatus >::value_type const &'):
        return _amici.SteadyStateStatusVector_push_back(self, x)

    def front(self) -> 'std::vector< enum amici::SteadyStateStatus >::value_type const &':
        return _amici.SteadyStateStatusVector_front(self)

    def back(self) -> 'std::vector< enum amici::SteadyStateStatus >::value_type const &':
        return _amici.SteadyStateStatusVector_back(self)

    def assign(self, n: int, x: 'std::vector< enum amici::SteadyStateStatus >::value_type const &'):
        return _amici.SteadyStateStatusVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.SteadyStateStatusVector_resize(self, *args)

    def insert(self, *args):
        return _amici.SteadyStateStatusVector_insert(self, *args)

    def reserve(self, n: int):
        return _amici.SteadyStateStatusVector_reserve(self, n)

    def capacity(self) -> int:
        return _amici.SteadyStateStatusVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_SteadyStateStatusVector
_amici.SteadyStateStatusVector_swigregister(SteadyStateStatusVector)